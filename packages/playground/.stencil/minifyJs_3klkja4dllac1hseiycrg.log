var DEFAULT_DELIMITER = "/", DEFAULT_DELIMITERS = "./", PATH_REGEXP = new RegExp([ "(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?" ].join("|"), "g");

function parse(e, t) {
  for (var n, r = [], a = 0, i = 0, s = "", o = t && t.delimiter || DEFAULT_DELIMITER, u = t && t.delimiters || DEFAULT_DELIMITERS, c = !1; null !== (n = PATH_REGEXP.exec(e)); ) {
    var h = n[0], p = n[1], l = n.index;
    if (s += e.slice(i, l), i = l + h.length, p) s += p[1], c = !0; else {
      var f = "", d = e[i], g = n[2], v = n[3], m = n[4], E = n[5];
      if (!c && s.length) {
        var x = s.length - 1;
        u.indexOf(s[x]) > -1 && (f = s[x], s = s.slice(0, x));
      }
      s && (r.push(s), s = "", c = !1);
      var y = f || o, A = v || m;
      r.push({
        name: g || a++,
        prefix: f,
        delimiter: y,
        optional: "?" === E || "*" === E,
        repeat: "+" === E || "*" === E,
        partial: "" !== f && void 0 !== d && d !== f,
        pattern: A ? escapeGroup(A) : "[^" + escapeString(y) + "]+?"
      });
    }
  }
  return (s || i < e.length) && r.push(s + e.substr(i)), r;
}

function escapeString(e) {
  return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
}

function escapeGroup(e) {
  return e.replace(/([=!:$\/()])/g, "\\$1");
}

function flags(e) {
  return e && e.sensitive ? "" : "i";
}

function regexpToRegexp(e, t) {
  if (!t) return e;
  var n = e.source.match(/\((?!\?)/g);
  if (n) for (var r = 0; r < n.length; r++) t.push({
    name: r,
    prefix: null,
    delimiter: null,
    optional: !1,
    repeat: !1,
    partial: !1,
    pattern: null
  });
  return e;
}

function arrayToRegexp(e, t, n) {
  for (var r = [], a = 0; a < e.length; a++) r.push(pathToRegexp(e[a], t, n).source);
  return new RegExp("(?:" + r.join("|") + ")", flags(n));
}

function stringToRegexp(e, t, n) {
  return tokensToRegExp(parse(e, n), t, n);
}

function tokensToRegExp(e, t, n) {
  for (var r = (n = n || {}).strict, a = !1 !== n.end, i = escapeString(n.delimiter || DEFAULT_DELIMITER), s = n.delimiters || DEFAULT_DELIMITERS, o = [].concat(n.endsWith || []).map(escapeString).concat("$").join("|"), u = "", c = !1, h = 0; h < e.length; h++) {
    var p = e[h];
    if ("string" == typeof p) u += escapeString(p), c = h === e.length - 1 && s.indexOf(p[p.length - 1]) > -1; else {
      var l = escapeString(p.prefix || ""), f = p.repeat ? "(?:" + p.pattern + ")(?:" + l + "(?:" + p.pattern + "))*" : p.pattern;
      t && t.push(p), u += p.optional ? p.partial ? l + "(" + f + ")?" : "(?:" + l + "(" + f + "))?" : l + "(" + f + ")";
    }
  }
  return a ? (r || (u += "(?:" + i + ")?"), u += "$" === o ? "$" : "(?=" + o + ")") : (r || (u += "(?:" + i + "(?=" + o + "))?"), 
  c || (u += "(?=" + i + "|" + o + ")")), new RegExp("^" + u, flags(n));
}

function pathToRegexp(e, t, n) {
  return e instanceof RegExp ? regexpToRegexp(e, t) : Array.isArray(e) ? arrayToRegexp(e, t, n) : stringToRegexp(e, t, n);
}

function hasBasename(e, t) {
  return new RegExp("^" + t + "(\\/|\\?|#|$)", "i").test(e);
}

function stripBasename(e, t) {
  return hasBasename(e, t) ? e.substr(t.length) : e;
}

function stripTrailingSlash(e) {
  return "/" === e.charAt(e.length - 1) ? e.slice(0, -1) : e;
}

function addLeadingSlash(e) {
  return "/" === e.charAt(0) ? e : "/" + e;
}

function stripLeadingSlash(e) {
  return "/" === e.charAt(0) ? e.substr(1) : e;
}

function parsePath(e) {
  var t = e || "/", n = "", r = "", a = t.indexOf("#");
  -1 !== a && (r = t.substr(a), t = t.substr(0, a));
  var i = t.indexOf("?");
  return -1 !== i && (n = t.substr(i), t = t.substr(0, i)), {
    pathname: t,
    search: "?" === n ? "" : n,
    hash: "#" === r ? "" : r,
    query: {},
    key: ""
  };
}

function createPath(e) {
  var t = e.search, n = e.hash, r = e.pathname || "/";
  return t && "?" !== t && (r += "?" === t.charAt(0) ? t : "?" + t), n && "#" !== n && (r += "#" === n.charAt(0) ? n : "#" + n), 
  r;
}

function parseQueryString(e) {
  return e ? (/^[?#]/.test(e) ? e.slice(1) : e).split("&").reduce(function(e, t) {
    var n = t.split("="), r = n[1];
    return e[n[0]] = r ? decodeURIComponent(r.replace(/\+/g, " ")) : "", e;
  }, {}) : {};
}

function isAbsolute(e) {
  return "/" === e.charAt(0);
}

function createKey(e) {
  return Math.random().toString(36).substr(2, e);
}

function spliceOne(e, t) {
  for (var n = t, r = n + 1, a = e.length; r < a; n += 1, r += 1) e[n] = e[r];
  e.pop();
}

function resolvePathname(e, t) {
  void 0 === t && (t = "");
  var n, r = e && e.split("/") || [], a = t && t.split("/") || [], i = e && isAbsolute(e), s = t && isAbsolute(t), o = i || s;
  if (e && isAbsolute(e) ? a = r : r.length && (a.pop(), a = a.concat(r)), !a.length) return "/";
  if (a.length) {
    var u = a[a.length - 1];
    n = "." === u || ".." === u || "" === u;
  } else n = !1;
  for (var c = 0, h = a.length; h >= 0; h--) {
    var p = a[h];
    "." === p ? spliceOne(a, h) : ".." === p ? (spliceOne(a, h), c++) : c && (spliceOne(a, h), 
    c--);
  }
  if (!o) for (;c--; c) a.unshift("..");
  !o || "" === a[0] || a[0] && isAbsolute(a[0]) || a.unshift("");
  var l = a.join("/");
  return n && "/" !== l.substr(-1) && (l += "/"), l;
}

function valueEqual(e, t) {
  if (e === t) return !0;
  if (null == e || null == t) return !1;
  if (Array.isArray(e)) return Array.isArray(t) && e.length === t.length && e.every(function(e, n) {
    return valueEqual(e, t[n]);
  });
  var n = typeof e;
  if (n !== typeof t) return !1;
  if ("object" === n) {
    var r = e.valueOf(), a = t.valueOf();
    if (r !== e || a !== t) return valueEqual(r, a);
    var i = Object.keys(e), s = Object.keys(t);
    return i.length === s.length && i.every(function(n) {
      return valueEqual(e[n], t[n]);
    });
  }
  return !1;
}

function locationsAreEqual(e, t) {
  return e.pathname === t.pathname && e.search === t.search && e.hash === t.hash && e.key === t.key && valueEqual(e.state, t.state);
}

function createLocation(e, t, n, r) {
  var a;
  "string" == typeof e ? void 0 !== (a = parsePath(e)).state && (a.state = t) : ((a = Object.assign({
    pathname: ""
  }, e)).search && "?" !== a.search.charAt(0) && (a.search = "?" + a.search), a.hash && "#" !== a.hash.charAt(0) && (a.hash = "#" + a.hash), 
  void 0 !== t && void 0 === a.state && (a.state = t));
  try {
    a.pathname = decodeURI(a.pathname);
  } catch (e) {
    throw e instanceof URIError ? new URIError('Pathname "' + a.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.') : e;
  }
  return a.key = n, r ? a.pathname ? "/" !== a.pathname.charAt(0) && (a.pathname = resolvePathname(a.pathname, r.pathname)) : a.pathname = r.pathname : a.pathname || (a.pathname = "/"), 
  a.query = parseQueryString(a.search || ""), a;
}

var patternCache = {}, cacheLimit = 1e4, cacheCount = 0;

function compilePath(e, t) {
  var n = "" + t.end + t.strict, r = patternCache[n] || (patternCache[n] = {}), a = JSON.stringify(e);
  if (r[a]) return r[a];
  var i = [], s = {
    re: pathToRegexp(e, i, t),
    keys: i
  };
  return cacheCount < cacheLimit && (r[a] = s, cacheCount += 1), s;
}

function matchPath(e, t) {
  void 0 === t && (t = {}), "string" == typeof t && (t = {
    path: t
  });
  var n = t.path, r = void 0 === n ? "/" : n, a = t.exact, i = void 0 !== a && a, s = t.strict, o = compilePath(r, {
    end: i,
    strict: void 0 !== s && s
  }), u = o.keys, c = o.re.exec(e);
  if (!c) return null;
  var h = c[0], p = c.slice(1), l = e === h;
  return i && !l ? null : {
    path: r,
    url: "/" === r && "" === h ? "/" : h,
    isExact: l,
    params: u.reduce(function(e, t, n) {
      return e[t.name] = p[n], e;
    }, {})
  };
}

function matchesAreEqual(e, t) {
  return null == e && null == t || null != t && e && t && e.path === t.path && e.url === t.url && valueEqual(e.params, t.params);
}

var canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement), addEventListener = function(e, t, n) {
  return e.addEventListener ? e.addEventListener(t, n, !1) : e.attachEvent("on" + t, n);
}, removeEventListener = function(e, t, n) {
  return e.removeEventListener ? e.removeEventListener(t, n, !1) : e.detachEvent("on" + t, n);
}, getConfirmation = function(e, t) {
  return t(window.confirm(e));
}, isModifiedEvent = function(e) {
  return e.metaKey || e.altKey || e.ctrlKey || e.shiftKey;
}, supportsHistory = function() {
  var e = window.navigator.userAgent;
  return (-1 === e.indexOf("Android 2.") && -1 === e.indexOf("Android 4.0") || -1 === e.indexOf("Mobile Safari") || -1 !== e.indexOf("Chrome") || -1 !== e.indexOf("Windows Phone")) && window.history && "pushState" in window.history;
}, supportsPopStateOnHashChange = function() {
  return -1 === window.navigator.userAgent.indexOf("Trident");
}, supportsGoWithoutReloadUsingHash = function() {
  return -1 === window.navigator.userAgent.indexOf("Firefox");
}, isExtraneousPopstateEvent = function(e) {
  return void 0 === e.state && -1 === navigator.userAgent.indexOf("CriOS");
}, storageAvailable = function(e) {
  var t = window[e], n = "__storage_test__";
  try {
    return t.setItem(n, n), t.removeItem(n), !0;
  } catch (e) {
    return e instanceof DOMException && (22 === e.code || 1014 === e.code || "QuotaExceededError" === e.name || "NS_ERROR_DOM_QUOTA_REACHED" === e.name) && 0 !== t.length;
  }
};

export { matchPath as a, matchesAreEqual as b, storageAvailable as c, canUseDOM as d, supportsHistory as e, supportsPopStateOnHashChange as f, getConfirmation as g, stripTrailingSlash as h, addLeadingSlash as i, hasBasename as j, stripBasename as k, createLocation as l, createKey as m, createPath as n, addEventListener as o, removeEventListener as p, isExtraneousPopstateEvent as q, supportsGoWithoutReloadUsingHash as r, stripLeadingSlash as s, locationsAreEqual as t, isModifiedEvent as u };
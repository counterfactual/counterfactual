{"moduleFile":{"sourceFilePath":"/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/components/app-root/app-root.tsx","localImports":["/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/data/account","/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/data/app-registry","/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/data/counterfactual","/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/data/firebase","/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/data/playground-api-client","/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/data/wallet"],"externalImports":["@counterfactual/node","@counterfactual/types","@stencil/core","@stencil/router","ethers","ethers/utils","@counterfactual/types"],"potentialCmpRefs":[{"tag":"stencil-router-redirect"},{"tag":"widget-dialog"},{"tag":"widget-spinner"},{"tag":"stencil-router"},{"tag":"stencil-route-switch"},{"tag":"stencil-route"},{"tag":"app-home"},{"tag":"webthree-connector"}],"cmpMeta":{"tagNameMeta":"app-root","stylesMeta":{"$":{"externalStyles":[{"absolutePath":"/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/components/app-root/app-root.scss","cmpRelativePath":"app-root.scss","originalComponentPath":"app-root.scss"}]}},"assetsDirsMeta":[],"hostMeta":{},"dependencies":[],"jsdoc":{"name":"AppRoot","tags":[],"documentation":"","type":"typeof AppRoot"},"encapsulationMeta":1,"componentClass":"AppRoot","membersMeta":{"loading":{"memberType":16},"accountState":{"memberType":16},"walletState":{"memberType":16},"appRegistryState":{"memberType":16},"hasLocalStorage":{"memberType":16},"balancePolling":{"memberType":16},"modal":{"memberType":16},"redirect":{"memberType":16}},"eventsMeta":[],"listenersMeta":[]},"hasSlot":false,"hasSvg":false,"jsFilePath":"/home/arjun/repositories/counterfactual/monorepo/packages/playground/src/components/app-root/app-root.js"},"jsText":"import { Node } from \"@counterfactual/types\";\r\nimport AccountTunnel from \"../../data/account\";\r\nimport AppRegistryTunnel from \"../../data/app-registry\";\r\nimport CounterfactualNode from \"../../data/counterfactual\";\r\nimport FirebaseDataProvider from \"../../data/firebase\";\r\nimport PlaygroundAPIClient from \"../../data/playground-api-client\";\r\nimport WalletTunnel from \"../../data/wallet\";\r\nconst TIER = \"ENV:TIER\";\r\nconst FIREBASE_SERVER_HOST = \"ENV:FIREBASE_SERVER_HOST\";\r\nconst FIREBASE_SERVER_PORT = \"ENV:FIREBASE_SERVER_PORT\";\r\nconst FIREBASE_API_KEY = \"ENV:FIREBASE_API_KEY\";\r\nconst FIREBASE_AUTH_DOMAIN = \"ENV:FIREBASE_AUTH_DOMAIN\";\r\nconst FIREBASE_DATABASE_URL = \"ENV:FIREBASE_DATABASE_URL\";\r\nconst FIREBASE_MESSAGING_SENDER_ID = \"ENV:FIREBASE_MESSAGING_SENDER_ID\";\r\nconst FIREBASE_PROJECT_ID = \"ENV:FIREBASE_PROJECT_ID\";\r\nconst FIREBASE_STORAGE_BUCKET = \"ENV:FIREBASE_STORAGE_BUCKET\";\r\nconst NETWORK_NAME_URL_PREFIX_ON_ETHERSCAN = {\r\n    \"42\": \"kovan\"\r\n};\r\nconst HEARTBEAT_INTERVAL = 30 * 1000;\r\nexport class AppRoot {\r\n    constructor() {\r\n        this.loading = true;\r\n        this.accountState = {\r\n            enoughCounterpartyBalance: true,\r\n            enoughLocalBalance: true\r\n        };\r\n        this.walletState = {};\r\n        this.appRegistryState = {\r\n            apps: [],\r\n            canUseApps: false,\r\n            schemaVersion: \"\",\r\n            maintenanceMode: false\r\n        };\r\n        this.hasLocalStorage = false;\r\n        this.modal = h(\"div\", null);\r\n        this.redirect = h(\"div\", null);\r\n    }\r\n    componentWillLoad() {\r\n        try {\r\n            localStorage.setItem(\"playground:localStorage\", \"true\");\r\n            localStorage.removeItem(\"playground:localStorage\");\r\n            this.hasLocalStorage = true;\r\n        }\r\n        catch (_a) {\r\n            this.hasLocalStorage = false;\r\n        }\r\n        this.setup();\r\n    }\r\n    async updateAccount(newProps) {\r\n        this.accountState = Object.assign({}, this.accountState, newProps);\r\n        this.bindProviderEvents();\r\n        this.setSentryUser(this.accountState);\r\n    }\r\n    setSentryUser(accountState) {\r\n        window[\"Sentry\"].configureScope(scope => {\r\n            scope.setUser({\r\n                email: accountState.user.email,\r\n                username: accountState.user.username,\r\n                id: accountState.user.id\r\n            });\r\n            scope.setExtra(\"ethAddress\", accountState.user.ethAddress);\r\n            scope.setExtra(\"multisigAddress\", accountState.user.multisigAddress);\r\n            scope.setExtra(\"nodeAddress\", accountState.user.nodeAddress);\r\n        });\r\n    }\r\n    async updateWalletConnection(newProps) {\r\n        this.walletState = Object.assign({}, this.walletState, newProps);\r\n    }\r\n    async updateAppRegistry(newProps) {\r\n        this.appRegistryState = Object.assign({}, this.appRegistryState, newProps);\r\n    }\r\n    async updateMultisigBalance(ethBalance) {\r\n        if (ethBalance.eq(window[\"ethers\"].constants.Zero) &&\r\n            this.accountState.ethPendingDepositAmountWei) {\r\n            return;\r\n        }\r\n        this.updateAccount({\r\n            ethMultisigBalance: ethBalance,\r\n            ethPendingDepositAmountWei: undefined\r\n        });\r\n    }\r\n    async updateWalletBalance(ethWeb3WalletBalance) {\r\n        await this.updateWalletConnection({ ethWeb3WalletBalance });\r\n    }\r\n    async setup() {\r\n        this.loadEnv();\r\n        this.loadSentry();\r\n        if (typeof window[\"web3\"] !== \"undefined\") {\r\n            await Promise.all([\r\n                this.heartbeat(),\r\n                this.createNodeProvider(),\r\n                this.loadApps()\r\n            ]);\r\n        }\r\n        this.loading = false;\r\n    }\r\n    async redirectToDeposit() {\r\n        this.modal = {};\r\n        this.redirect = h(\"stencil-router-redirect\", { url: \"/deposit\" });\r\n    }\r\n    async createNodeProvider() {\r\n        if (!this.hasLocalStorage) {\r\n            return;\r\n        }\r\n        let configuration;\r\n        if (TIER === \"dev\") {\r\n            configuration = {\r\n                databaseURL: `ws://${FIREBASE_SERVER_HOST}:${FIREBASE_SERVER_PORT}`,\r\n                projectId: \"\",\r\n                apiKey: \"\",\r\n                authDomain: \"\",\r\n                storageBucket: \"\",\r\n                messagingSenderId: \"\"\r\n            };\r\n        }\r\n        else {\r\n            configuration = {\r\n                apiKey: FIREBASE_API_KEY,\r\n                authDomain: FIREBASE_AUTH_DOMAIN,\r\n                databaseURL: FIREBASE_DATABASE_URL,\r\n                projectId: FIREBASE_PROJECT_ID,\r\n                storageBucket: FIREBASE_STORAGE_BUCKET,\r\n                messagingSenderId: FIREBASE_MESSAGING_SENDER_ID\r\n            };\r\n        }\r\n        FirebaseDataProvider.create(configuration);\r\n        const messagingService = FirebaseDataProvider.createMessagingService(\"messaging\");\r\n        const storeService = {\r\n            async get(desiredKey) {\r\n                const entries = {};\r\n                const allKeys = Object.keys(window.localStorage);\r\n                for (const key of allKeys) {\r\n                    if (key.includes(desiredKey)) {\r\n                        const val = JSON.parse(window.localStorage.getItem(key));\r\n                        if (key === desiredKey)\r\n                            return val;\r\n                        entries[key] = val;\r\n                    }\r\n                }\r\n                for (const key of Object.keys(entries)) {\r\n                    const leafKey = key.split(\"/\")[key.split(\"/\").length - 1];\r\n                    const value = entries[key];\r\n                    delete entries[key];\r\n                    entries[leafKey] = value;\r\n                }\r\n                return Object.keys(entries).length > 0 ? entries : undefined;\r\n            },\r\n            async set(pairs) {\r\n                pairs.forEach(({ key, value }) => {\r\n                    window.localStorage.setItem(key, JSON.stringify(value));\r\n                });\r\n            }\r\n        };\r\n        await CounterfactualNode.create({\r\n            messagingService,\r\n            storeService,\r\n            nodeConfig: {\r\n                STORE_KEY_PREFIX: \"store\"\r\n            },\r\n            network: \"kovan\"\r\n        });\r\n    }\r\n    loadEnv() {\r\n        if (TIER === \"dev\") {\r\n            window[\"globalConfig\"] = {\r\n                TIER: \"dev\"\r\n            };\r\n        }\r\n        else {\r\n            window[\"globalConfig\"] = {\r\n                TIER\r\n            };\r\n        }\r\n    }\r\n    loadSentry() {\r\n        if (TIER === \"dev\") {\r\n        }\r\n        else {\r\n            window[\"Sentry\"].init({\r\n                dsn: \"https://6037586d37124e518f4718d9dd46b18b@sentry.io/1383439\",\r\n                release: `playground@${Date.now()}`,\r\n                environment: TIER\r\n            });\r\n        }\r\n    }\r\n    async loadApps() {\r\n        const apps = await PlaygroundAPIClient.getApps();\r\n        await this.updateAppRegistry({ apps });\r\n    }\r\n    async heartbeat() {\r\n        setInterval(async () => this.doHeartbeat(), HEARTBEAT_INTERVAL);\r\n        this.doHeartbeat();\r\n    }\r\n    async doHeartbeat() {\r\n        const heartbeat = await PlaygroundAPIClient.getHeartbeat();\r\n        this.updateAppRegistry(Object.assign({}, heartbeat));\r\n    }\r\n    bindProviderEvents() {\r\n        const { user: { multisigAddress, ethAddress } } = this.accountState;\r\n        const { provider } = this.walletState;\r\n        if (!provider || !multisigAddress || !ethAddress) {\r\n            return;\r\n        }\r\n        if (ethAddress) {\r\n            provider.removeAllListeners(ethAddress);\r\n            provider.on(ethAddress, this.updateWalletBalance.bind(this));\r\n        }\r\n        if (multisigAddress) {\r\n            provider.removeAllListeners(multisigAddress);\r\n            provider.on(multisigAddress, this.updateMultisigBalance.bind(this));\r\n        }\r\n    }\r\n    buildSignatureMessageForLogin(address) {\r\n        return [\"PLAYGROUND ACCOUNT LOGIN\", `Ethereum address: ${address}`].join(\"\\n\");\r\n    }\r\n    async login() {\r\n        const { user } = this.accountState;\r\n        const signer = this.walletState.signer;\r\n        const signature = await signer.signMessage(this.buildSignatureMessageForLogin(user.ethAddress));\r\n        const loggedUser = await PlaygroundAPIClient.login({\r\n            ethAddress: user.ethAddress\r\n        }, signature);\r\n        window.localStorage.setItem(\"playground:user:token\", loggedUser.token);\r\n        await this.updateAccount({ user: loggedUser });\r\n        await this.getBalances();\r\n        return loggedUser;\r\n    }\r\n    async deleteAccount() {\r\n        const token = window.localStorage.getItem(\"playground:user:token\");\r\n        if (!token) {\r\n            console.error(\"Couldn't delete account; no token was provided\");\r\n            return;\r\n        }\r\n        const user = await PlaygroundAPIClient.getUser(token);\r\n        try {\r\n            await PlaygroundAPIClient.deleteAccount(user);\r\n            this.updateAccount({ hasCorruptStateChannelState: false });\r\n        }\r\n        finally {\r\n            this.logout();\r\n            return;\r\n        }\r\n    }\r\n    async getBalances({ poll = false } = {}) {\r\n        const MINIMUM_EXPECTED_FREE_BALANCE = window[\"ethers\"].utils.parseEther(\"0.01\");\r\n        const { user: { multisigAddress, ethAddress, nodeAddress } } = this.accountState;\r\n        const { provider } = this.walletState;\r\n        const cfProvider = CounterfactualNode.getCfProvider();\r\n        if (!multisigAddress || !ethAddress) {\r\n            return {\r\n                ethFreeBalanceWei: window[\"ethers\"].constants.Zero,\r\n                ethMultisigBalance: window[\"ethers\"].constants.Zero\r\n            };\r\n        }\r\n        let freeBalance;\r\n        try {\r\n            freeBalance = await cfProvider.getFreeBalanceState(multisigAddress);\r\n        }\r\n        catch (e) {\r\n            if (e.toString().includes(\"Call to getFreeBalanceState failed\")) {\r\n                await this.updateAccount({ hasCorruptStateChannelState: true });\r\n                return {\r\n                    ethFreeBalanceWei: window[\"ethers\"].constants.Zero,\r\n                    ethMultisigBalance: window[\"ethers\"].constants.Zero\r\n                };\r\n            }\r\n            throw e;\r\n        }\r\n        const getAddress = (xkey, k) => window[\"ethers\"].utils.computeAddress(window[\"ethers\"].utils.HDNode.fromExtendedKey(xkey).derivePath(String(k)).publicKey);\r\n        const myFreeBalanceAddress = getAddress(nodeAddress, 0);\r\n        const [counterpartyFreeBalanceAddress] = Object.keys(freeBalance).filter(addr => addr !== myFreeBalanceAddress);\r\n        const myBalance = freeBalance[myFreeBalanceAddress];\r\n        const counterpartyBalance = freeBalance[counterpartyFreeBalanceAddress];\r\n        const vals = {\r\n            ethFreeBalanceWei: myBalance,\r\n            ethMultisigBalance: (await provider.getBalance(multisigAddress)),\r\n            ethCounterpartyFreeBalanceWei: counterpartyBalance\r\n        };\r\n        const enoughCounterpartyBalance = counterpartyBalance.gte(MINIMUM_EXPECTED_FREE_BALANCE);\r\n        const enoughLocalBalance = myBalance.gte(MINIMUM_EXPECTED_FREE_BALANCE);\r\n        const canUseApps = enoughCounterpartyBalance && enoughLocalBalance;\r\n        await this.updateAppRegistry({\r\n            canUseApps\r\n        });\r\n        await this.updateAccount(Object.assign({}, vals, { enoughCounterpartyBalance,\r\n            enoughLocalBalance }));\r\n        if (poll) {\r\n            if (canUseApps) {\r\n                clearTimeout(this.balancePolling);\r\n            }\r\n            else {\r\n                this.balancePolling = setTimeout(async () => this.getBalances({ poll }), 1000);\r\n            }\r\n        }\r\n        return vals;\r\n    }\r\n    async resetPendingDepositState() {\r\n        await this.updateAccount({\r\n            ethPendingDepositAmountWei: undefined,\r\n            ethPendingDepositTxHash: undefined\r\n        });\r\n    }\r\n    async resetPendingWithdrawalState() {\r\n        await this.updateAccount({\r\n            ethPendingWithdrawalAmountWei: undefined,\r\n            ethPendingWithdrawalTxHash: undefined\r\n        });\r\n    }\r\n    async deposit(valueInWei) {\r\n        const token = localStorage.getItem(\"playground:user:token\");\r\n        const { multisigAddress } = await PlaygroundAPIClient.getUser(token);\r\n        const provider = CounterfactualNode.getCfProvider();\r\n        provider.once(Node.EventName.DEPOSIT_STARTED, async (args) => {\r\n            console.log(\"Playground#deposit: DEPOSIT_STARTED\");\r\n            await this.updateAccount({\r\n                ethPendingDepositTxHash: args.txHash,\r\n                ethPendingDepositAmountWei: valueInWei\r\n            });\r\n        });\r\n        provider.once(Node.EventName.DEPOSIT_CONFIRMED, async (args) => {\r\n            await this.getBalances();\r\n            await this.resetPendingDepositState();\r\n        });\r\n        let ret;\r\n        try {\r\n            const amount = window[\"ethers\"].utils.bigNumberify(valueInWei);\r\n            ret = await provider.deposit(multisigAddress, amount);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n        return ret;\r\n    }\r\n    async withdraw(valueInWei) {\r\n        const { user: { multisigAddress } } = this.accountState;\r\n        const provider = CounterfactualNode.getCfProvider();\r\n        provider.once(Node.EventName.WITHDRAWAL_STARTED, args => {\r\n            this.updateAccount({\r\n                ethPendingWithdrawalTxHash: args.txHash,\r\n                ethPendingWithdrawalAmountWei: valueInWei\r\n            });\r\n        });\r\n        let ret;\r\n        try {\r\n            const amount = window[\"ethers\"].utils.bigNumberify(valueInWei);\r\n            ret = await provider.withdraw(multisigAddress, amount, this.accountState.user.ethAddress);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n        await this.getBalances();\r\n        await this.resetPendingWithdrawalState();\r\n        return ret;\r\n    }\r\n    waitForMultisig() {\r\n        const provider = CounterfactualNode.getCfProvider();\r\n        provider.once(Node.EventName.CREATE_CHANNEL, this.setMultisigAddress.bind(this));\r\n    }\r\n    async setMultisigAddress(createChannelMsg) {\r\n        const { user } = this.accountState;\r\n        user.multisigAddress = createChannelMsg.data.multisigAddress;\r\n        await this.updateAccount({ user });\r\n    }\r\n    async autoLogin() {\r\n        const token = window.localStorage.getItem(\"playground:user:token\");\r\n        if (!token) {\r\n            return;\r\n        }\r\n        const { user } = this.accountState;\r\n        if (!user || !user.username) {\r\n            try {\r\n                const loggedUser = await PlaygroundAPIClient.getUser(token);\r\n                this.updateAccount({ user: loggedUser });\r\n            }\r\n            catch (_a) {\r\n                this.logout();\r\n                return;\r\n            }\r\n        }\r\n        if (!this.accountState.user.multisigAddress) {\r\n            this.waitForMultisig();\r\n        }\r\n        else {\r\n            await this.getBalances();\r\n        }\r\n    }\r\n    logout() {\r\n        window.localStorage.removeItem(\"playground:user:token\");\r\n        this.updateAccount({ user: {} });\r\n    }\r\n    getEtherscanAddressURL(address) {\r\n        return `https://${NETWORK_NAME_URL_PREFIX_ON_ETHERSCAN[this.walletState.network]}.etherscan.io/address/${address}`;\r\n    }\r\n    getEtherscanTxURL(tx) {\r\n        return `https://${NETWORK_NAME_URL_PREFIX_ON_ETHERSCAN[this.walletState.network]}.etherscan.io/tx/${tx}`;\r\n    }\r\n    upgrade() {\r\n        const keysToPreserve = [\"MNEMONIC\", \"playground:matchmakeWith\"];\r\n        const preservedKeys = keysToPreserve\r\n            .map(key => ({ [key]: localStorage.getItem(key) }))\r\n            .reduce((obj, keyContainer) => (Object.assign({}, obj, keyContainer)), {});\r\n        window.localStorage.clear();\r\n        keysToPreserve.forEach(key => {\r\n            window.localStorage.setItem(key, preservedKeys[key]);\r\n        });\r\n        window.localStorage.setItem(\"playground:schemaVersion\", this.appRegistryState.schemaVersion);\r\n        window.location.reload();\r\n    }\r\n    render() {\r\n        this.accountState = Object.assign({}, this.accountState, { updateAccount: this.updateAccount.bind(this), waitForMultisig: this.waitForMultisig.bind(this), login: this.login.bind(this), logout: this.logout.bind(this), deleteAccount: this.deleteAccount.bind(this), getBalances: this.getBalances.bind(this), autoLogin: this.autoLogin.bind(this), deposit: this.deposit.bind(this), withdraw: this.withdraw.bind(this) });\r\n        this.walletState.updateWalletConnection = this.updateWalletConnection.bind(this);\r\n        this.walletState.getEtherscanAddressURL = this.getEtherscanAddressURL.bind(this);\r\n        this.walletState.getEtherscanTxURL = this.getEtherscanTxURL.bind(this);\r\n        this.appRegistryState.updateAppRegistry = this.updateAppRegistry.bind(this);\r\n        if (this.appRegistryState.maintenanceMode) {\r\n            return (h(\"widget-dialog\", { visible: true, dialogTitle: \"Under maintenance\", content: h(\"p\", null,\r\n                    \"Sorry! We're currently working on a few things behind the scenes to keep the demo functional. Please come back later. In the meantime, follow us on Twitter\",\r\n                    h(\"a\", { href: \"https://twitter.com/statechannels\", target: \"_blank\" },\r\n                        \" \",\r\n                        \"@statechannels\",\r\n                        \" \"),\r\n                    \"to learn more and keep up to date on the project.\") }));\r\n        }\r\n        if (this.loading) {\r\n            return h(\"widget-spinner\", { type: \"dots\" });\r\n        }\r\n        const localSchemaVersion = window.localStorage.getItem(\"playground:schemaVersion\");\r\n        if (localSchemaVersion &&\r\n            localSchemaVersion !== this.appRegistryState.schemaVersion) {\r\n            return (h(\"widget-dialog\", { visible: true, dialogTitle: \"A new version of the Playground is available!\", content: \"Click OK to update your experience.\", primaryButtonText: \"OK\", onPrimaryButtonClicked: this.upgrade.bind(this) }));\r\n        }\r\n        return (h(WalletTunnel.Provider, { state: this.walletState },\r\n            h(AccountTunnel.Provider, { state: this.accountState },\r\n                h(AppRegistryTunnel.Provider, { state: this.appRegistryState },\r\n                    h(\"div\", { class: \"app-root wrapper\" },\r\n                        h(\"main\", { class: \"wrapper__content\" }, this.hasLocalStorage ? (h(\"stencil-router\", null,\r\n                            h(\"stencil-route-switch\", { scrollTopOffset: 0 },\r\n                                h(\"stencil-route\", { url: \"/\", component: \"app-home\", exact: true, componentProps: {\r\n                                        hasLocalStorage: this.hasLocalStorage\r\n                                    } }),\r\n                                h(\"stencil-route\", { url: \"/dapp/:dappName\", component: \"dapp-container\" }),\r\n                                h(\"stencil-route\", { url: \"/account\", component: \"account-edit\" }),\r\n                                h(\"stencil-route\", { url: \"/exchange\", component: \"account-exchange\" }),\r\n                                h(\"stencil-route\", { url: \"/register\", component: \"account-register\" }),\r\n                                h(\"stencil-route\", { url: \"/deposit\", component: \"account-deposit\" })))) : (h(\"app-home\", { hasLocalStorage: this.hasLocalStorage }))),\r\n                        h(\"webthree-connector\", { accountState: this.accountState, walletState: this.walletState }),\r\n                        this.modal || {},\r\n                        this.redirect || {})))));\r\n    }\r\n    static get is() { return \"app-root\"; }\r\n    static get encapsulation() { return \"shadow\"; }\r\n    static get properties() { return {\r\n        \"accountState\": {\r\n            \"state\": true\r\n        },\r\n        \"appRegistryState\": {\r\n            \"state\": true\r\n        },\r\n        \"balancePolling\": {\r\n            \"state\": true\r\n        },\r\n        \"hasLocalStorage\": {\r\n            \"state\": true\r\n        },\r\n        \"loading\": {\r\n            \"state\": true\r\n        },\r\n        \"modal\": {\r\n            \"state\": true\r\n        },\r\n        \"redirect\": {\r\n            \"state\": true\r\n        },\r\n        \"walletState\": {\r\n            \"state\": true\r\n        }\r\n    }; }\r\n    static get style() { return \"/**style-placeholder:app-root:**/\"; }\r\n}\r\n"}
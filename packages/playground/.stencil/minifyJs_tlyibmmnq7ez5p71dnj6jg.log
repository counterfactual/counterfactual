import * as tslib_1 from "../polyfills/tslib.js";

import { h } from "../app.core.js";

import "./chunk-deed3e85.js";

import { a as AccountTunnel } from "./chunk-dfef6d51.js";

import { a as AppRegistryTunnel } from "./chunk-868ccbc3.js";

import { a as CounterfactualNode, b as Node$1 } from "./chunk-515d15f9.js";

import { a as WalletTunnel } from "./chunk-a343ce23.js";

import { a as PlaygroundAPIClient } from "./chunk-adf5a5b1.js";

import { a as matchPath, b as matchesAreEqual, c as storageAvailable, d as canUseDOM, e as supportsHistory, f as supportsPopStateOnHashChange, g as getConfirmation, h as stripTrailingSlash, i as addLeadingSlash, j as hasBasename, k as stripBasename, l as createLocation, m as createKey, n as createPath, o as addEventListener, p as removeEventListener, q as isExtraneousPopstateEvent, r as supportsGoWithoutReloadUsingHash, s as stripLeadingSlash, t as locationsAreEqual } from "./chunk-8b806219.js";

import { a as ActiveRouter } from "./chunk-9cf92136.js";

var AppHome = /** @class */ function() {
  function AppHome() {
    this.history = {}, this.apps = [], this.canUseApps = !1, this.user = {}, this.web3Detected = !1, 
    this.hasDetectedNetwork = !1, this.networkPermitted = !1, this.enoughCounterpartyBalance = !0, 
    this.enoughLocalBalance = !0, this.ethPendingDepositTxHash = "", this.hasLocalStorage = !1, 
    this.hasCorruptStateChannelState = !1, this.runningApps = [];
  }
  return AppHome.prototype.appClickedHandler = function(t) {
    this.history.push(t.detail.dappContainerUrl, t.detail);
  }, AppHome.prototype.componentWillLoad = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(t) {
        return this.runningApps = [ Object.assign({}, this.apps[0], {
          notifications: 11
        }) ], [ 2 /*return*/ ];
      });
    });
  }, AppHome.prototype.checkLocalStorage = function() {
    if (!this.hasLocalStorage) {
      var t, e = {
        brave: {
          title: "Please, lower your Shields!",
          instruction: h("span", null, "Please, turn off the ", h("i", null, "Shields Up"), " feature for this site to continue.")
        },
        chrome: {
          title: "Please, allow site data!",
          instruction: h("span", null, "Please, unblock ", h("i", null, "Cookies"), " in your settings, under", " ", h("i", null, "Privacy → Content settings"), ".")
        },
        edge: {
          title: "Please, unblock us!",
          instruction: h("span", null, "Please, uncheck the ", h("i", null, "Block all cookies"), " option in your settings, under ", h("i", null, "Advanced Settings → Cookies"), ".")
        },
        firefox: {
          title: "Please, enable DOM Storage!",
          instruction: h("span", null, "Please, set the ", h("code", null, "dom.storage.enabled"), " key to", " ", h("code", null, "true"), " in your ", h("code", null, "about:config"), " screen.")
        },
        safari: {
          title: "Please, unblock us!",
          instruction: h("span", null, "Please, uncheck the ", h("i", null, "Always block"), " option in your settings, under ", h("i", null, "Preferences → Privacy → Cookies and website data"), ".")
        },
        default: {
          title: "Please, allow us to store data",
          instruction: h("span", null, "The Playground demo uses Local Storage to work properly. Please, configure your browser to grant us access.")
        }
      };
      return t = navigator.userAgent.indexOf("brave") >= 0 ? e.brave : navigator.userAgent.indexOf("Chrome") >= 0 && navigator.vendor.indexOf("Google") >= 0 ? e.chrome : navigator.userAgent.indexOf("Edge") >= 0 ? e.edge : navigator.userAgent.indexOf("Safari") >= 0 ? e.safari : navigator.userAgent.indexOf("Firefox") >= 0 ? e.firefox : e.default, 
      h("div", {
        class: "error-message"
      }, h("h1", null, t.title), h("h2", null, "The Playground Demo uses Local Storage to work properly.", " ", t.instruction), h("p", null, h("strong", null, "What do we store?"), " Basic information the demo needs to work, such as a mnemonic key to generate the address for your local Node instance, and the data the Node itself stores about the activity in the state channels you are part of."));
    }
  }, AppHome.prototype.checkDetectedNetwork = function() {
    if (!this.hasDetectedNetwork) return h("widget-spinner", {
      type: "dots"
    });
  }, AppHome.prototype.getSuggestedWallet = function() {
    return screen.width < 600 ? h("span", null, h("a", {
      href: "https://wallet.coinbase.com/"
    }, "Coinbase Wallet"), ",", h("a", {
      href: "https://www.cipherbrowser.com/"
    }, " Cipher"), ", or", h("a", {
      href: "https://dev.status.im/"
    }, " Status")) : h("a", {
      href: "https://metamask.io/"
    }, "Metamask");
  }, AppHome.prototype.checkWeb3Detected = function() {
    if (!this.web3Detected) return h("div", {
      class: "error-message"
    }, h("h2", null, "Welcome to the Playground demo :) This demo requires a Web3-compatible wallet such as ", this.getSuggestedWallet(), ". Please enable or download one to continue!"));
  }, AppHome.prototype.checkNetworkPermitted = function() {
    if (!this.networkPermitted) return h("div", {
      class: "error-message"
    }, h("h1", null, "Please Switch to Kovan"), h("h2", null, "The Playground demo is currently only deployed on the Kovan test network. Please switch to continue."));
  }, AppHome.prototype.checkCorruptState = function() {
    if (this.hasCorruptStateChannelState) return h("div", {
      class: "error-message"
    }, h("h1", null, "☠️ Corrupt Wallet State"), h("h2", null, "Unfortunately, your state channel state has become corrupted or lost. Please ", h("a", {
      onClick: this.deleteAccount
    }, "click here"), " to start over."));
  }, AppHome.prototype.showApps = function() {
    var t = this;
    return h("div", {
      class: "container"
    }, h("apps-list", {
      apps: this.apps,
      onAppClicked: function(e) {
        return t.appClickedHandler(e);
      },
      name: "Available Apps"
    }), this.welcomeText());
  }, AppHome.prototype.checkUserNotLoggedIn = function() {
    if (!this.user.id) return this.welcomeText();
  }, AppHome.prototype.welcomeText = function() {
    return h("div", {
      class: "welcome-message",
      style: {
        display: this.user.id ? "contents" : "flex"
      }
    }, this.user.id ? void 0 : h("h1", null, "Welcome! 👋"), this.user.id ? void 0 : h("h2", null, "This a demonstration of", " ", h("a", {
      href: "https://counterfactual.com/statechannels"
    }, "generalized state channels"), " ", "on Ethereum."), h("div", {
      class: "flex-container"
    }, h("div", {
      class: "flex-item"
    }, h("h3", null, "What's going on here?"), h("p", null, "You are now a Node in a hub-and-spoke state channels network demo called the Counterfactual Playground, running on Kovan. This webpage is your state channels wallet. Our team runs the hub. Users that connect to our hub can use an unlimited number of off-chain applications with ", h("b", null, "zero fees"), " and", " ", h("b", null, "zero block confirmation times"), ". Want to try? Register or login to start.")), h("div", {
      class: "flex-item"
    }, h("h3", null, "How does it work?"), h("p", null, "This demo is built using", " ", h("a", {
      href: "https://counterfactual.com"
    }, "Counterfactual"), ". We've written all about the internal architecture in", " ", h("a", {
      href: "https://medium.com/statechannels/development-update-3-counterfactual-playground-release-f428be4b8950"
    }, "this blog post"), ". To learn more, check out our", " ", h("a", {
      href: "https://github.com/counterfactual"
    }, "GitHub"), " page and follow us on", " ", h("a", {
      href: "https://twitter.com/statechannels"
    }, "Twitter")))), h("div", {
      class: "flex-container"
    }, h("div", {
      class: "flex-item"
    }, h("h3", null, "What is Counterfactual?"), h("p", null, "Counterfactual is an open-source project comprised of several components:", h("ul", null, h("li", null, "• A library for off-chain applications"), h("li", null, "• An intuitive generalized state channels protocol"), h("li", null, "• A set of Ethereum smart contracts")), " ", "It enables developers to build trustless distributed applications with minimal overhead. Watch", " ", h("a", {
      href: "https://youtu.be/tfKtLNlPL2w?t=72",
      target: "_blank"
    }, "our recent talk"), " ", "at EthCC for more.")), h("div", {
      class: "flex-item"
    }, h("h3", null, "How is this secure?"), h("p", null, "Counterfactual uses state channels, a Layer 2 scalability technique. For a complete overview, read", " ", h("a", {
      href: "https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4",
      target: "_blank"
    }, "Making Sense of Layer 2"), " ", "or watch the associated", " ", h("a", {
      href: "https://www.youtube.com/watch?v=RghzB4C9aSg",
      target: "_blank"
    }, "talk from Devcon IV"), "."))));
  }, AppHome.prototype.checkInsufficientBalance = function() {
    if (this.user && this.user.multisigAddress) return this.enoughLocalBalance ? this.enoughCounterpartyBalance ? void 0 : h("div", {
      class: "error-message"
    }, h("h1", null, "The Playground Node has insufficient funds"), h("h2", null, "Eventually we'll take care of this automatically, but in the meantime, you'll need to deposit some ETH.", h("br", null), h("br", null), h("stencil-route-link", {
      url: "/exchange"
    }, "Click here"), " ", "to deposit more funds.")) : h("div", {
      class: "error-message"
    }, h("h1", null, "Insufficient funds"), h("h2", null, "Your balance needs to be of at least 0.01 ETH.", h("br", null), h("br", null), h("stencil-route-link", {
      url: "/exchange"
    }, "Click here"), " ", "to deposit more funds."));
  }, AppHome.prototype.render = function() {
    var t = this.checkLocalStorage() || this.checkDetectedNetwork() || this.checkWeb3Detected() || this.checkNetworkPermitted() || this.checkUserNotLoggedIn() || this.checkInsufficientBalance() || this.checkCorruptState() || this.showApps();
    return this.hasLocalStorage ? h("node-listener", {
      history: this.history
    }, h("layout-header", null), h("section", {
      class: "section fill"
    }, t), h("a", {
      id: "discordbutton",
      href: "https://discord.gg/7SMbDz",
      target: "_blank"
    })) : h("div", null, h("layout-header", null), h("section", {
      class: "section fill"
    }, t));
  }, Object.defineProperty(AppHome, "is", {
    get: function() {
      return "app-home";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(AppHome, "encapsulation", {
    get: function() {
      return "shadow";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(AppHome, "properties", {
    get: function() {
      return {
        apps: {
          type: "Any",
          attr: "apps"
        },
        canUseApps: {
          type: Boolean,
          attr: "can-use-apps"
        },
        deleteAccount: {
          type: "Any",
          attr: "delete-account"
        },
        element: {
          elementRef: !0
        },
        enoughCounterpartyBalance: {
          type: Boolean,
          attr: "enough-counterparty-balance"
        },
        enoughLocalBalance: {
          type: Boolean,
          attr: "enough-local-balance"
        },
        ethPendingDepositAmountWei: {
          type: "Any",
          attr: "eth-pending-deposit-amount-wei"
        },
        ethPendingDepositTxHash: {
          type: String,
          attr: "eth-pending-deposit-tx-hash"
        },
        hasCorruptStateChannelState: {
          type: Boolean,
          attr: "has-corrupt-state-channel-state"
        },
        hasDetectedNetwork: {
          type: Boolean,
          attr: "has-detected-network"
        },
        hasLocalStorage: {
          type: Boolean,
          attr: "has-local-storage"
        },
        history: {
          type: "Any",
          attr: "history"
        },
        networkPermitted: {
          type: Boolean,
          attr: "network-permitted"
        },
        runningApps: {
          state: !0
        },
        user: {
          type: "Any",
          attr: "user"
        },
        web3Detected: {
          type: Boolean,
          attr: "web-3-detected"
        }
      };
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(AppHome, "style", {
    get: function() {
      return "/**style-placeholder:app-home:**/";
    },
    enumerable: !0,
    configurable: !0
  }), AppHome;
}();

AppRegistryTunnel.injectProps(AppHome, [ "apps", "canUseApps" ]), WalletTunnel.injectProps(AppHome, [ "web3Detected", "networkPermitted", "hasDetectedNetwork" ]), 
AccountTunnel.injectProps(AppHome, [ "user", "hasCorruptStateChannelState", "enoughCounterpartyBalance", "enoughLocalBalance", "ethPendingDepositAmountWei", "ethPendingDepositTxHash", "deleteAccount" ]);

var FirebaseService = /** @class */ function() {
  function FirebaseService() {}
  return FirebaseService.create = function(t) {
    if (FirebaseService.app) return FirebaseService.app;
    FirebaseService.app = window.firebase.initializeApp(t);
  }, FirebaseService.createMessagingService = function(t) {
    return new FirebaseMessagingService(FirebaseService.app.database(), t);
  }, FirebaseService.createStoreService = function(t) {
    return new FirebaseStoreService(FirebaseService.app.database(), t);
  }, FirebaseService;
}(), FirebaseMessagingService = /** @class */ function() {
  function FirebaseMessagingService(t, e) {
    this.firebase = t, this.messagingServerKey = e;
  }
  return FirebaseMessagingService.prototype.send = function(t, e) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(n) {
        switch (n.label) {
         case 0:
          return [ 4 /*yield*/ , this.firebase.ref(this.messagingServerKey + "/" + t + "/" + e.from).set(JSON.parse(JSON.stringify(e))) ];

         case 1:
          return n.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, FirebaseMessagingService.prototype.onReceive = function(t, e) {
    var n = this;
    this.firebase.app ? (this.firebase.ref(this.messagingServerKey + "/" + t).remove(), 
    this.firebase.ref(this.messagingServerKey + "/" + t).on("child_added", function(o) {
      return tslib_1.__awaiter(n, void 0, void 0, function() {
        var n;
        return tslib_1.__generator(this, function(r) {
          switch (r.label) {
           case 0:
            return o ? null === (n = o.val()) ? [ 2 /*return*/ ] : (n.from !== o.key && console.error("Incorrect message received", n), 
            [ 4 /*yield*/ , this.firebase.ref(this.messagingServerKey + "/" + t + "/" + n.from).remove() ]) : (console.error("Node with address " + t + ' received a "null" snapshot'), 
            [ 2 /*return*/ ]);

           case 1:
            r.sent();
            try {
              console.log("Received message from", t, n, "Handling via", e), e(n);
            } catch (t) {
              console.error("Encountered an error while handling message callback", t);
            }
            return [ 2 /*return*/ ];
          }
        });
      });
    })) : console.error("Cannot register a connection with an uninitialized firebase handle");
  }, FirebaseMessagingService;
}(), FirebaseStoreService = /** @class */ function() {
  function FirebaseStoreService(t, e) {
    this.firebase = t, this.storeServiceKey = e;
  }
  return FirebaseStoreService.prototype.get = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var e;
      return tslib_1.__generator(this, function(n) {
        switch (n.label) {
         case 0:
          return [ 4 /*yield*/ , this.firebase.ref(this.storeServiceKey).child(t).once("value", function(n) {
            null !== n ? e = n.val() : console.debug("Failed to retrieve value at " + t + ': received a "null" snapshot');
          }) ];

         case 1:
          return n.sent(), [ 2 /*return*/ , e ];
        }
      });
    });
  }, FirebaseStoreService.prototype.set = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var e, n, o, r;
      return tslib_1.__generator(this, function(i) {
        switch (i.label) {
         case 0:
          for (e = {}, n = 0, o = t; n < o.length; n++) e[(r = o[n]).key] = JSON.parse(JSON.stringify(r.value));
          return [ 4 /*yield*/ , this.firebase.ref(this.storeServiceKey).update(e) ];

         case 1:
          return i.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, FirebaseStoreService;
}(), TIER = "production", FIREBASE_API_KEY = "", FIREBASE_AUTH_DOMAIN = "", FIREBASE_DATABASE_URL = "", FIREBASE_MESSAGING_SENDER_ID = "", FIREBASE_PROJECT_ID = "", FIREBASE_STORAGE_BUCKET = "", NETWORK_NAME_URL_PREFIX_ON_ETHERSCAN = {
  42: "kovan"
}, HEARTBEAT_INTERVAL = 3e4, AppRoot = /** @class */ function() {
  function AppRoot() {
    this.loading = !0, this.accountState = {
      enoughCounterpartyBalance: !0,
      enoughLocalBalance: !0
    }, this.walletState = {}, this.appRegistryState = {
      apps: [],
      canUseApps: !1,
      schemaVersion: "",
      maintenanceMode: !1
    }, this.hasLocalStorage = !1, this.modal = h("div", null), this.redirect = h("div", null);
  }
  return AppRoot.prototype.componentWillLoad = function() {
    try {
      localStorage.setItem("playground:localStorage", "true"), localStorage.removeItem("playground:localStorage"), 
      this.hasLocalStorage = !0;
    } catch (t) {
      this.hasLocalStorage = !1;
    }
    this.setup();
  }, AppRoot.prototype.updateAccount = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(e) {
        return this.accountState = Object.assign({}, this.accountState, t), this.bindProviderEvents(), 
        this.setSentryUser(this.accountState), [ 2 /*return*/ ];
      });
    });
  }, AppRoot.prototype.setSentryUser = function(t) {
    window.Sentry.configureScope(function(e) {
      e.setUser({
        email: t.user.email,
        username: t.user.username,
        id: t.user.id
      }), e.setExtra("ethAddress", t.user.ethAddress), e.setExtra("multisigAddress", t.user.multisigAddress), 
      e.setExtra("nodeAddress", t.user.nodeAddress);
    });
  }, AppRoot.prototype.updateWalletConnection = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(e) {
        return this.walletState = Object.assign({}, this.walletState, t), [ 2 /*return*/ ];
      });
    });
  }, AppRoot.prototype.updateAppRegistry = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(e) {
        return this.appRegistryState = Object.assign({}, this.appRegistryState, t), [ 2 /*return*/ ];
      });
    });
  }, AppRoot.prototype.updateMultisigBalance = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(e) {
        return t.eq(window.ethers.constants.Zero) && this.accountState.ethPendingDepositAmountWei ? [ 2 /*return*/ ] : (this.updateAccount({
          ethMultisigBalance: t,
          ethPendingDepositAmountWei: void 0
        }), [ 2 /*return*/ ]);
      });
    });
  }, AppRoot.prototype.updateWalletBalance = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(e) {
        switch (e.label) {
         case 0:
          return [ 4 /*yield*/ , this.updateWalletConnection({
            ethWeb3WalletBalance: t
          }) ];

         case 1:
          return e.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.setup = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(t) {
        switch (t.label) {
         case 0:
          return this.loadEnv(), this.loadSentry(), void 0 === window.web3 ? [ 3 /*break*/ , 2 ] : [ 4 /*yield*/ , Promise.all([ this.heartbeat(), this.createNodeProvider(), this.loadApps() ]) ];

         case 1:
          t.sent(), t.label = 2;

         case 2:
          return this.loading = !1, [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.redirectToDeposit = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(t) {
        return this.modal = {}, this.redirect = h("stencil-router-redirect", {
          url: "/deposit"
        }), [ 2 /*return*/ ];
      });
    });
  }, AppRoot.prototype.createNodeProvider = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t;
      return tslib_1.__generator(this, function(e) {
        switch (e.label) {
         case 0:
          return this.hasLocalStorage ? (FirebaseService.create({
            apiKey: FIREBASE_API_KEY,
            authDomain: FIREBASE_AUTH_DOMAIN,
            databaseURL: FIREBASE_DATABASE_URL,
            projectId: FIREBASE_PROJECT_ID,
            storageBucket: FIREBASE_STORAGE_BUCKET,
            messagingSenderId: FIREBASE_MESSAGING_SENDER_ID
          }), t = FirebaseService.createMessagingService("messaging"), [ 4 /*yield*/ , CounterfactualNode.create({
            messagingService: t,
            storeService: {
              get: function(t) {
                return tslib_1.__awaiter(this, void 0, void 0, function() {
                  var e, n, o, r, i, a, s, c, u, l;
                  return tslib_1.__generator(this, function(h) {
                    for (e = {}, n = Object.keys(window.localStorage), o = 0, r = n; o < r.length; o++) if ((c = r[o]).includes(t)) {
                      if (i = JSON.parse(window.localStorage.getItem(c)), c === t) return [ 2 /*return*/ , i ];
                      e[c] = i;
                    }
                    for (a = 0, s = Object.keys(e); a < s.length; a++) u = (c = s[a]).split("/")[c.split("/").length - 1], 
                    l = e[c], delete e[c], e[u] = l;
                    return [ 2 /*return*/ , Object.keys(e).length > 0 ? e : void 0 ];
                  });
                });
              },
              set: function(t) {
                return tslib_1.__awaiter(this, void 0, void 0, function() {
                  return tslib_1.__generator(this, function(e) {
                    return t.forEach(function(t) {
                      window.localStorage.setItem(t.key, JSON.stringify(t.value));
                    }), [ 2 /*return*/ ];
                  });
                });
              }
            },
            nodeConfig: {
              STORE_KEY_PREFIX: "store"
            },
            network: "kovan"
          }) ]) : [ 2 /*return*/ ];

         case 1:
          return e.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.loadEnv = function() {
    window.globalConfig = {
      TIER: TIER
    };
  }, AppRoot.prototype.loadSentry = function() {
    window.Sentry.init({
      dsn: "https://6037586d37124e518f4718d9dd46b18b@sentry.io/1383439",
      release: "playground@" + Date.now(),
      environment: TIER
    });
  }, AppRoot.prototype.loadApps = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t;
      return tslib_1.__generator(this, function(e) {
        switch (e.label) {
         case 0:
          return [ 4 /*yield*/ , PlaygroundAPIClient.getApps() ];

         case 1:
          return t = e.sent(), [ 4 /*yield*/ , this.updateAppRegistry({
            apps: t
          }) ];

         case 2:
          return e.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.heartbeat = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t = this;
      return tslib_1.__generator(this, function(e) {
        return setInterval(function() {
          return tslib_1.__awaiter(t, void 0, void 0, function() {
            return tslib_1.__generator(this, function(t) {
              return [ 2 /*return*/ , this.doHeartbeat() ];
            });
          });
        }, HEARTBEAT_INTERVAL), this.doHeartbeat(), [ 2 /*return*/ ];
      });
    });
  }, AppRoot.prototype.doHeartbeat = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t;
      return tslib_1.__generator(this, function(e) {
        switch (e.label) {
         case 0:
          return [ 4 /*yield*/ , PlaygroundAPIClient.getHeartbeat() ];

         case 1:
          return t = e.sent(), this.updateAppRegistry(Object.assign({}, t)), [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.bindProviderEvents = function() {
    var t = this.accountState.user, e = t.multisigAddress, n = t.ethAddress, o = this.walletState.provider;
    o && e && n && (n && (o.removeAllListeners(n), o.on(n, this.updateWalletBalance.bind(this))), 
    e && (o.removeAllListeners(e), o.on(e, this.updateMultisigBalance.bind(this))));
  }, AppRoot.prototype.buildSignatureMessageForLogin = function(t) {
    return [ "PLAYGROUND ACCOUNT LOGIN", "Ethereum address: " + t ].join("\n");
  }, AppRoot.prototype.login = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t, e, n;
      return tslib_1.__generator(this, function(o) {
        switch (o.label) {
         case 0:
          return [ 4 /*yield*/ , this.walletState.signer.signMessage(this.buildSignatureMessageForLogin((t = this.accountState.user).ethAddress)) ];

         case 1:
          return e = o.sent(), [ 4 /*yield*/ , PlaygroundAPIClient.login({
            ethAddress: t.ethAddress
          }, e) ];

         case 2:
          return n = o.sent(), window.localStorage.setItem("playground:user:token", n.token), 
          [ 4 /*yield*/ , this.updateAccount({
            user: n
          }) ];

         case 3:
          return o.sent(), [ 4 /*yield*/ , this.getBalances() ];

         case 4:
          return o.sent(), [ 2 /*return*/ , n ];
        }
      });
    });
  }, AppRoot.prototype.deleteAccount = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t, e;
      return tslib_1.__generator(this, function(n) {
        switch (n.label) {
         case 0:
          return (t = window.localStorage.getItem("playground:user:token")) ? [ 4 /*yield*/ , PlaygroundAPIClient.getUser(t) ] : (console.error("Couldn't delete account; no token was provided"), 
          [ 2 /*return*/ ]);

         case 1:
          e = n.sent(), n.label = 2;

         case 2:
          return n.trys.push([ 2, , 4, 5 ]), [ 4 /*yield*/ , PlaygroundAPIClient.deleteAccount(e) ];

         case 3:
          return n.sent(), this.updateAccount({
            hasCorruptStateChannelState: !1
          }), [ 3 /*break*/ , 5 ];

         case 4:
          return this.logout(), [ 2 /*return*/ ];

         case 5:
          return [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.getBalances = function(t) {
    var e = (void 0 === t ? {} : t).poll, n = void 0 !== e && e;
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t, e, o, r, i, a, s, c, u, l, h, p, d, f, g, w, b, y, v = this;
      return tslib_1.__generator(this, function(m) {
        switch (m.label) {
         case 0:
          if (t = window.ethers.utils.parseEther("0.01"), o = (e = this.accountState.user).multisigAddress, 
          r = e.ethAddress, i = e.nodeAddress, a = this.walletState.provider, s = CounterfactualNode.getCfProvider(), 
          !o || !r) return [ 2 /*return*/ , {
            ethFreeBalanceWei: window.ethers.constants.Zero,
            ethMultisigBalance: window.ethers.constants.Zero
          } ];
          m.label = 1;

         case 1:
          return m.trys.push([ 1, 3, , 6 ]), [ 4 /*yield*/ , s.getFreeBalanceState(o) ];

         case 2:
          return c = m.sent(), [ 3 /*break*/ , 6 ];

         case 3:
          return (u = m.sent()).toString().includes("Call to getFreeBalanceState failed") ? [ 4 /*yield*/ , this.updateAccount({
            hasCorruptStateChannelState: !0
          }) ] : [ 3 /*break*/ , 5 ];

         case 4:
          return m.sent(), [ 2 /*return*/ , {
            ethFreeBalanceWei: window.ethers.constants.Zero,
            ethMultisigBalance: window.ethers.constants.Zero
          } ];

         case 5:
          throw u;

         case 6:
          return l = window.ethers.utils.computeAddress(window.ethers.utils.HDNode.fromExtendedKey(i).derivePath(String(0)).publicKey), 
          h = Object.keys(c).filter(function(t) {
            return t !== l;
          })[0], d = c[h], g = {
            ethFreeBalanceWei: p = c[l]
          }, [ 4 /*yield*/ , a.getBalance(o) ];

         case 7:
          return g.ethMultisigBalance = m.sent(), g.ethCounterpartyFreeBalanceWei = d, f = g, 
          w = d.gte(t), b = p.gte(t), [ 4 /*yield*/ , this.updateAppRegistry({
            canUseApps: y = w && b
          }) ];

         case 8:
          return m.sent(), [ 4 /*yield*/ , this.updateAccount(Object.assign({}, f, {
            enoughCounterpartyBalance: w,
            enoughLocalBalance: b
          })) ];

         case 9:
          return m.sent(), n && (y ? clearTimeout(this.balancePolling) : this.balancePolling = setTimeout(function() {
            return tslib_1.__awaiter(v, void 0, void 0, function() {
              return tslib_1.__generator(this, function(t) {
                return [ 2 /*return*/ , this.getBalances({
                  poll: n
                }) ];
              });
            });
          }, 1e3)), [ 2 /*return*/ , f ];
        }
      });
    });
  }, AppRoot.prototype.resetPendingDepositState = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(t) {
        switch (t.label) {
         case 0:
          return [ 4 /*yield*/ , this.updateAccount({
            ethPendingDepositAmountWei: void 0,
            ethPendingDepositTxHash: void 0
          }) ];

         case 1:
          return t.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.resetPendingWithdrawalState = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(t) {
        switch (t.label) {
         case 0:
          return [ 4 /*yield*/ , this.updateAccount({
            ethPendingWithdrawalAmountWei: void 0,
            ethPendingWithdrawalTxHash: void 0
          }) ];

         case 1:
          return t.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.deposit = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var e, n, o, r, i, a, s = this;
      return tslib_1.__generator(this, function(c) {
        switch (c.label) {
         case 0:
          return e = localStorage.getItem("playground:user:token"), [ 4 /*yield*/ , PlaygroundAPIClient.getUser(e) ];

         case 1:
          n = c.sent().multisigAddress, (o = CounterfactualNode.getCfProvider()).once(Node$1.EventName.DEPOSIT_STARTED, function(e) {
            return tslib_1.__awaiter(s, void 0, void 0, function() {
              return tslib_1.__generator(this, function(n) {
                switch (n.label) {
                 case 0:
                  return console.log("Playground#deposit: DEPOSIT_STARTED"), [ 4 /*yield*/ , this.updateAccount({
                    ethPendingDepositTxHash: e.txHash,
                    ethPendingDepositAmountWei: t
                  }) ];

                 case 1:
                  return n.sent(), [ 2 /*return*/ ];
                }
              });
            });
          }), o.once(Node$1.EventName.DEPOSIT_CONFIRMED, function(t) {
            return tslib_1.__awaiter(s, void 0, void 0, function() {
              return tslib_1.__generator(this, function(t) {
                switch (t.label) {
                 case 0:
                  return [ 4 /*yield*/ , this.getBalances() ];

                 case 1:
                  return t.sent(), [ 4 /*yield*/ , this.resetPendingDepositState() ];

                 case 2:
                  return t.sent(), [ 2 /*return*/ ];
                }
              });
            });
          }), c.label = 2;

         case 2:
          return c.trys.push([ 2, 4, , 5 ]), i = window.ethers.utils.bigNumberify(t), [ 4 /*yield*/ , o.deposit(n, i) ];

         case 3:
          return r = c.sent(), [ 3 /*break*/ , 5 ];

         case 4:
          return a = c.sent(), console.error(a), [ 3 /*break*/ , 5 ];

         case 5:
          return [ 2 /*return*/ , r ];
        }
      });
    });
  }, AppRoot.prototype.withdraw = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var e, n, o, r, i, a = this;
      return tslib_1.__generator(this, function(s) {
        switch (s.label) {
         case 0:
          e = this.accountState.user.multisigAddress, (n = CounterfactualNode.getCfProvider()).once(Node$1.EventName.WITHDRAWAL_STARTED, function(e) {
            a.updateAccount({
              ethPendingWithdrawalTxHash: e.txHash,
              ethPendingWithdrawalAmountWei: t
            });
          }), s.label = 1;

         case 1:
          return s.trys.push([ 1, 3, , 4 ]), r = window.ethers.utils.bigNumberify(t), [ 4 /*yield*/ , n.withdraw(e, r, this.accountState.user.ethAddress) ];

         case 2:
          return o = s.sent(), [ 3 /*break*/ , 4 ];

         case 3:
          return i = s.sent(), console.error(i), [ 3 /*break*/ , 4 ];

         case 4:
          return [ 4 /*yield*/ , this.getBalances() ];

         case 5:
          return s.sent(), [ 4 /*yield*/ , this.resetPendingWithdrawalState() ];

         case 6:
          return s.sent(), [ 2 /*return*/ , o ];
        }
      });
    });
  }, AppRoot.prototype.waitForMultisig = function() {
    CounterfactualNode.getCfProvider().once(Node$1.EventName.CREATE_CHANNEL, this.setMultisigAddress.bind(this));
  }, AppRoot.prototype.setMultisigAddress = function(t) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var e;
      return tslib_1.__generator(this, function(n) {
        switch (n.label) {
         case 0:
          return (e = this.accountState.user).multisigAddress = t.data.multisigAddress, [ 4 /*yield*/ , this.updateAccount({
            user: e
          }) ];

         case 1:
          return n.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.autoLogin = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t, e, n;
      return tslib_1.__generator(this, function(o) {
        switch (o.label) {
         case 0:
          if (!(t = window.localStorage.getItem("playground:user:token"))) return [ 2 /*return*/ ];
          if ((e = this.accountState.user) && e.username) return [ 3 /*break*/ , 4 ];
          o.label = 1;

         case 1:
          return o.trys.push([ 1, 3, , 4 ]), [ 4 /*yield*/ , PlaygroundAPIClient.getUser(t) ];

         case 2:
          return n = o.sent(), this.updateAccount({
            user: n
          }), [ 3 /*break*/ , 4 ];

         case 3:
          return o.sent(), this.logout(), [ 2 /*return*/ ];

         case 4:
          return this.accountState.user.multisigAddress ? [ 3 /*break*/ , 5 ] : (this.waitForMultisig(), 
          [ 3 /*break*/ , 7 ]);

         case 5:
          return [ 4 /*yield*/ , this.getBalances() ];

         case 6:
          o.sent(), o.label = 7;

         case 7:
          return [ 2 /*return*/ ];
        }
      });
    });
  }, AppRoot.prototype.logout = function() {
    window.localStorage.removeItem("playground:user:token"), this.updateAccount({
      user: {}
    });
  }, AppRoot.prototype.getEtherscanAddressURL = function(t) {
    return "https://" + NETWORK_NAME_URL_PREFIX_ON_ETHERSCAN[this.walletState.network] + ".etherscan.io/address/" + t;
  }, AppRoot.prototype.getEtherscanTxURL = function(t) {
    return "https://" + NETWORK_NAME_URL_PREFIX_ON_ETHERSCAN[this.walletState.network] + ".etherscan.io/tx/" + t;
  }, AppRoot.prototype.upgrade = function() {
    var t = [ "MNEMONIC", "playground:matchmakeWith" ], e = t.map(function(t) {
      var e;
      return (e = {})[t] = localStorage.getItem(t), e;
    }).reduce(function(t, e) {
      return Object.assign({}, t, e);
    }, {});
    window.localStorage.clear(), t.forEach(function(t) {
      window.localStorage.setItem(t, e[t]);
    }), window.localStorage.setItem("playground:schemaVersion", this.appRegistryState.schemaVersion), 
    window.location.reload();
  }, AppRoot.prototype.render = function() {
    if (this.accountState = Object.assign({}, this.accountState, {
      updateAccount: this.updateAccount.bind(this),
      waitForMultisig: this.waitForMultisig.bind(this),
      login: this.login.bind(this),
      logout: this.logout.bind(this),
      deleteAccount: this.deleteAccount.bind(this),
      getBalances: this.getBalances.bind(this),
      autoLogin: this.autoLogin.bind(this),
      deposit: this.deposit.bind(this),
      withdraw: this.withdraw.bind(this)
    }), this.walletState.updateWalletConnection = this.updateWalletConnection.bind(this), 
    this.walletState.getEtherscanAddressURL = this.getEtherscanAddressURL.bind(this), 
    this.walletState.getEtherscanTxURL = this.getEtherscanTxURL.bind(this), this.appRegistryState.updateAppRegistry = this.updateAppRegistry.bind(this), 
    this.appRegistryState.maintenanceMode) return h("widget-dialog", {
      visible: !0,
      dialogTitle: "Under maintenance",
      content: h("p", null, "Sorry! We're currently working on a few things behind the scenes to keep the demo functional. Please come back later. In the meantime, follow us on Twitter", h("a", {
        href: "https://twitter.com/statechannels",
        target: "_blank"
      }, " ", "@statechannels", " "), "to learn more and keep up to date on the project.")
    });
    if (this.loading) return h("widget-spinner", {
      type: "dots"
    });
    var t = window.localStorage.getItem("playground:schemaVersion");
    return t && t !== this.appRegistryState.schemaVersion ? h("widget-dialog", {
      visible: !0,
      dialogTitle: "A new version of the Playground is available!",
      content: "Click OK to update your experience.",
      primaryButtonText: "OK",
      onPrimaryButtonClicked: this.upgrade.bind(this)
    }) : h(WalletTunnel.Provider, {
      state: this.walletState
    }, h(AccountTunnel.Provider, {
      state: this.accountState
    }, h(AppRegistryTunnel.Provider, {
      state: this.appRegistryState
    }, h("div", {
      class: "app-root wrapper"
    }, h("main", {
      class: "wrapper__content"
    }, this.hasLocalStorage ? h("stencil-router", null, h("stencil-route-switch", {
      scrollTopOffset: 0
    }, h("stencil-route", {
      url: "/",
      component: "app-home",
      exact: !0,
      componentProps: {
        hasLocalStorage: this.hasLocalStorage
      }
    }), h("stencil-route", {
      url: "/dapp/:dappName",
      component: "dapp-container"
    }), h("stencil-route", {
      url: "/account",
      component: "account-edit"
    }), h("stencil-route", {
      url: "/exchange",
      component: "account-exchange"
    }), h("stencil-route", {
      url: "/register",
      component: "account-register"
    }), h("stencil-route", {
      url: "/deposit",
      component: "account-deposit"
    }))) : h("app-home", {
      hasLocalStorage: this.hasLocalStorage
    })), h("webthree-connector", {
      accountState: this.accountState,
      walletState: this.walletState
    }), this.modal || {}, this.redirect || {}))));
  }, Object.defineProperty(AppRoot, "is", {
    get: function() {
      return "app-root";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(AppRoot, "encapsulation", {
    get: function() {
      return "shadow";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(AppRoot, "properties", {
    get: function() {
      return {
        accountState: {
          state: !0
        },
        appRegistryState: {
          state: !0
        },
        balancePolling: {
          state: !0
        },
        hasLocalStorage: {
          state: !0
        },
        loading: {
          state: !0
        },
        modal: {
          state: !0
        },
        redirect: {
          state: !0
        },
        walletState: {
          state: !0
        }
      };
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(AppRoot, "style", {
    get: function() {
      return "/**style-placeholder:app-root:**/";
    },
    enumerable: !0,
    configurable: !0
  }), AppRoot;
}(), KOVAN_NETWORK_ID = "42", permittedNetworkIds = [ KOVAN_NETWORK_ID ], Web3Connector = /** @class */ function() {
  function Web3Connector() {
    this.accountState = {}, this.walletState = {};
  }
  return Web3Connector.prototype.getProvider = function() {
    return new window.ethers.providers.Web3Provider(window.web3.currentProvider);
  }, Web3Connector.prototype.getCurrentAddress = function() {
    return window.web3.eth.accounts[0];
  }, Web3Connector.prototype.getCurrentNetwork = function() {
    return window.web3.version.network;
  }, Web3Connector.prototype.getETHBalance = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t;
      return tslib_1.__generator(this, function(e) {
        switch (e.label) {
         case 0:
          return (t = this.getProvider()) && this.isUnlocked() ? [ 4 /*yield*/ , t.getSigner().getBalance() ] : [ 3 /*break*/ , 2 ];

         case 1:
          return [ 2 /*return*/ , e.sent() ];

         case 2:
          return [ 2 /*return*/ , window.ethers.constants.Zero ];
        }
      });
    });
  }, Web3Connector.prototype.isWeb3Detected = function() {
    return void 0 !== window.web3;
  }, Web3Connector.prototype.isMetamask = function() {
    return window.web3.isMetamask || window.web3.currentProvider.isMetamask;
  }, Web3Connector.prototype.isUnlocked = function() {
    return void 0 !== window.web3.eth.accounts[0];
  }, Web3Connector.prototype.isOnPermittedNetwork = function() {
    return permittedNetworkIds.includes(this.getCurrentNetwork());
  }, Web3Connector.prototype.getCurrentWalletState = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t;
      return tslib_1.__generator(this, function(e) {
        return (t = {
          network: "",
          connected: !1,
          metamaskUnlocked: !1,
          web3Detected: this.walletState.web3Detected,
          web3Enabled: this.walletState.web3Enabled,
          networkPermitted: !1,
          hasDetectedNetwork: !0
        }).metamaskUnlocked = this.isUnlocked(), t.networkPermitted = this.isOnPermittedNetwork(), 
        t.network = this.getCurrentNetwork(), [ 2 /*return*/ , t ];
      });
    });
  }, Web3Connector.prototype.componentDidLoad = function() {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var t, e, n, o, r, i, a = this;
      return tslib_1.__generator(this, function(s) {
        switch (s.label) {
         case 0:
          return this.isWeb3Detected() ? (this.accountState.updateAccount({
            user: Object.assign({}, this.accountState.user, {
              ethAddress: this.getCurrentAddress()
            })
          }), e = (t = this.walletState).updateWalletConnection, o = (n = Object).assign, 
          r = [ {} ], [ 4 /*yield*/ , this.getCurrentWalletState() ]) : [ 2 /*return*/ , this.walletState.updateWalletConnection({
            web3Detected: !1,
            hasDetectedNetwork: !0
          }) ];

         case 1:
          return e.apply(t, [ o.apply(n, r.concat([ s.sent(), {
            provider: this.getProvider(),
            signer: this.getProvider().getSigner(),
            web3Enabled: !0,
            web3Detected: !0
          } ])) ]), i = window.setInterval(function() {
            return tslib_1.__awaiter(a, void 0, void 0, function() {
              var t, e, n, o, r, a, s;
              return tslib_1.__generator(this, function(c) {
                switch (c.label) {
                 case 0:
                  return t = this.accountState.user.ethAddress, e = this.getCurrentAddress(), [ 4 /*yield*/ , this.accountState.updateAccount({
                    user: Object.assign({}, this.accountState.user, {
                      ethAddress: e
                    })
                  }) ];

                 case 1:
                  return c.sent(), o = (n = this.walletState).updateWalletConnection, r = {}, [ 4 /*yield*/ , this.getETHBalance() ];

                 case 2:
                  return [ 4 /*yield*/ , o.apply(n, [ (r.ethWeb3WalletBalance = c.sent(), r) ]) ];

                 case 3:
                  return c.sent(), e === t ? [ 3 /*break*/ , 5 ] : (s = (a = this.walletState).updateWalletConnection, 
                  [ 4 /*yield*/ , this.getCurrentWalletState() ]);

                 case 4:
                  s.apply(a, [ c.sent() ]), void 0 !== (t = e) && void 0 === e && clearInterval(i), 
                  c.label = 5;

                 case 5:
                  return [ 2 /*return*/ ];
                }
              });
            });
          }, 1e3), [ 2 /*return*/ ];
        }
      });
    });
  }, Object.defineProperty(Web3Connector, "is", {
    get: function() {
      return "webthree-connector";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(Web3Connector, "encapsulation", {
    get: function() {
      return "shadow";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(Web3Connector, "properties", {
    get: function() {
      return {
        accountState: {
          type: "Any",
          attr: "account-state"
        },
        walletState: {
          type: "Any",
          attr: "wallet-state"
        }
      };
    },
    enumerable: !0,
    configurable: !0
  }), Web3Connector;
}(), __awaiter = function(t, e, n, o) {
  return new (n || (n = Promise))(function(r, i) {
    function fulfilled(t) {
      try {
        step(o.next(t));
      } catch (t) {
        i(t);
      }
    }
    function rejected(t) {
      try {
        step(o.throw(t));
      } catch (t) {
        i(t);
      }
    }
    function step(t) {
      t.done ? r(t.value) : new n(function(e) {
        e(t.value);
      }).then(fulfilled, rejected);
    }
    step((o = o.apply(t, e || [])).next());
  });
}, Route = /** @class */ function() {
  function Route() {
    this.group = null, this.match = null, this.componentProps = {}, this.exact = !1, 
    this.scrollOnNextRender = !1, this.previousMatch = null;
  }
  return Route.prototype.computeMatch = function(t) {
    var e = null != this.group || null != this.el.parentElement && "stencil-route-switch" === this.el.parentElement.tagName.toLowerCase();
    if (t && !e) return this.previousMatch = this.match, this.match = matchPath(t.pathname, {
      path: this.url,
      exact: this.exact,
      strict: !0
    });
  }, Route.prototype.loadCompleted = function() {
    return __awaiter(this, void 0, void 0, function() {
      var t;
      return tslib_1.__generator(this, function(e) {
        return t = {}, this.history && this.history.location.hash ? t = {
          scrollToId: this.history.location.hash.substr(1)
        } : this.scrollTopOffset && (t = {
          scrollTopOffset: this.scrollTopOffset
        }), "function" == typeof this.componentUpdated ? this.componentUpdated(t) : this.match && !matchesAreEqual(this.match, this.previousMatch) && this.routeViewsUpdated && this.routeViewsUpdated(t), 
        [ 2 /*return*/ ];
      });
    });
  }, Route.prototype.componentDidUpdate = function() {
    return __awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(t) {
        switch (t.label) {
         case 0:
          return [ 4 /*yield*/ , this.loadCompleted() ];

         case 1:
          return t.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, Route.prototype.componentDidLoad = function() {
    return __awaiter(this, void 0, void 0, function() {
      return tslib_1.__generator(this, function(t) {
        switch (t.label) {
         case 0:
          return [ 4 /*yield*/ , this.loadCompleted() ];

         case 1:
          return t.sent(), [ 2 /*return*/ ];
        }
      });
    });
  }, Route.prototype.render = function() {
    if (!this.match || !this.history) return null;
    var t = Object.assign({}, this.componentProps, {
      history: this.history,
      match: this.match
    });
    return this.routeRender ? this.routeRender(Object.assign({}, t, {
      component: this.component
    })) : this.component ? h(this.component, Object.assign({}, t)) : void 0;
  }, Object.defineProperty(Route, "is", {
    get: function() {
      return "stencil-route";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(Route, "properties", {
    get: function() {
      return {
        component: {
          type: String,
          attr: "component"
        },
        componentProps: {
          type: "Any",
          attr: "component-props"
        },
        componentUpdated: {
          type: "Any",
          attr: "component-updated"
        },
        el: {
          elementRef: !0
        },
        exact: {
          type: Boolean,
          attr: "exact"
        },
        group: {
          type: String,
          attr: "group",
          reflectToAttr: !0
        },
        history: {
          type: "Any",
          attr: "history"
        },
        historyType: {
          type: String,
          attr: "history-type"
        },
        location: {
          type: "Any",
          attr: "location",
          watchCallbacks: [ "computeMatch" ]
        },
        match: {
          type: "Any",
          attr: "match",
          mutable: !0
        },
        routeRender: {
          type: "Any",
          attr: "route-render"
        },
        routeViewsUpdated: {
          type: "Any",
          attr: "route-views-updated"
        },
        scrollTopOffset: {
          type: Number,
          attr: "scroll-top-offset"
        },
        url: {
          type: String,
          attr: "url"
        }
      };
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(Route, "style", {
    get: function() {
      return "/**style-placeholder:stencil-route:**/";
    },
    enumerable: !0,
    configurable: !0
  }), Route;
}();

function uuidv4() {
  return ([ 1e7 ].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function(t) {
    return (t ^ window.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t / 4).toString(16);
  });
}

ActiveRouter.injectProps(Route, [ "location", "history", "historyType", "routeViewsUpdated" ]);

var __awaiter$1 = function(t, e, n, o) {
  return new (n || (n = Promise))(function(r, i) {
    function fulfilled(t) {
      try {
        step(o.next(t));
      } catch (t) {
        i(t);
      }
    }
    function rejected(t) {
      try {
        step(o.throw(t));
      } catch (t) {
        i(t);
      }
    }
    function step(t) {
      t.done ? r(t.value) : new n(function(e) {
        e(t.value);
      }).then(fulfilled, rejected);
    }
    step((o = o.apply(t, e || [])).next());
  });
};

function getUniqueId() {
  return window.crypto ? uuidv4() : ((1e17 * Math.random()).toString().match(/.{4}/g) || []).join("-");
}

function getMatch(t, e, n) {
  return matchPath(t, {
    path: e,
    exact: n,
    strict: !0
  });
}

function isHTMLStencilRouteElement(t) {
  return "stencil-route" === t.tagName.toLowerCase();
}

var RouteSwitch = /** @class */ function() {
  function RouteSwitch() {
    this.group = getUniqueId(), this.subscribers = [];
  }
  return RouteSwitch.prototype.componentWillLoad = function() {
    null != this.location && this.regenerateSubscribers(this.location);
  }, RouteSwitch.prototype.regenerateSubscribers = function(t) {
    return __awaiter$1(this, void 0, void 0, function() {
      var e, n, o = this;
      return tslib_1.__generator(this, function(r) {
        return null == t ? [ 2 /*return*/ ] : (e = -1, this.subscribers = Array.prototype.slice.call(this.el.children).filter(isHTMLStencilRouteElement).map(function(n, o) {
          var r = getMatch(t.pathname, n.url, n.exact);
          return r && -1 === e && (e = o), {
            el: n,
            match: r
          };
        }), -1 === e ? [ 2 /*return*/ ] : this.activeIndex === e ? (this.subscribers[e].el.match = this.subscribers[e].match, 
        [ 2 /*return*/ ]) : (this.activeIndex = e, n = this.subscribers[this.activeIndex], 
        this.scrollTopOffset && (n.el.scrollTopOffset = this.scrollTopOffset), n.el.group = this.group, 
        n.el.match = n.match, n.el.componentUpdated = function(t) {
          o.queue.write(function() {
            o.subscribers.forEach(function(t, e) {
              if (t.el.componentUpdated = void 0, e === o.activeIndex) return t.el.style.display = "";
              o.scrollTopOffset && (t.el.scrollTopOffset = o.scrollTopOffset), t.el.group = o.group, 
              t.el.match = null, t.el.style.display = "none";
            });
          }), o.routeViewsUpdated && o.routeViewsUpdated(Object.assign({
            scrollTopOffset: o.scrollTopOffset
          }, t));
        }, [ 2 /*return*/ ]));
      });
    });
  }, RouteSwitch.prototype.render = function() {
    return h("slot", null);
  }, Object.defineProperty(RouteSwitch, "is", {
    get: function() {
      return "stencil-route-switch";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(RouteSwitch, "properties", {
    get: function() {
      return {
        el: {
          elementRef: !0
        },
        group: {
          type: String,
          attr: "group",
          reflectToAttr: !0
        },
        location: {
          type: "Any",
          attr: "location",
          watchCallbacks: [ "regenerateSubscribers" ]
        },
        queue: {
          context: "queue"
        },
        routeViewsUpdated: {
          type: "Any",
          attr: "route-views-updated"
        },
        scrollTopOffset: {
          type: Number,
          attr: "scroll-top-offset"
        }
      };
    },
    enumerable: !0,
    configurable: !0
  }), RouteSwitch;
}();

function invariant(t) {
  for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
  t || console.error.apply(console, e);
}

function warning(t) {
  for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
  t || console.warn.apply(console, e);
}

ActiveRouter.injectProps(RouteSwitch, [ "location", "routeViewsUpdated" ]);

var createTransitionManager = function() {
  var t, e = [];
  return {
    setPrompt: function(e) {
      return warning(null == t, "A history supports only one prompt at a time"), t = e, 
      function() {
        t === e && (t = null);
      };
    },
    confirmTransitionTo: function(e, n, o, r) {
      if (null != t) {
        var i = "function" == typeof t ? t(e, n) : t;
        "string" == typeof i ? "function" == typeof o ? o(i, r) : (warning(!1, "A history needs a getUserConfirmation function in order to use a prompt message"), 
        r(!0)) : r(!1 !== i);
      } else r(!0);
    },
    appendListener: function(t) {
      var n = !0, o = function() {
        for (var e = [], o = 0; o < arguments.length; o++) e[o] = arguments[o];
        n && t.apply(void 0, e);
      };
      return e.push(o), function() {
        n = !1, e = e.filter(function(t) {
          return t !== o;
        });
      };
    },
    notifyListeners: function() {
      for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
      e.forEach(function(e) {
        return e.apply(void 0, t);
      });
    }
  };
}, createScrollHistory = function(t) {
  void 0 === t && (t = "scrollPositions");
  var e = new Map();
  if (storageAvailable("sessionStorage")) {
    var n = window.sessionStorage.getItem(t);
    e = n ? new Map(JSON.parse(n)) : e;
  }
  function set(t, n) {
    if (e.set(t, n), storageAvailable("sessionStorage")) {
      var o = [];
      e.forEach(function(t, e) {
        o.push([ e, t ]);
      }), window.sessionStorage.setItem("scrollPositions", JSON.stringify(o));
    }
  }
  return "scrollRestoration" in history && (history.scrollRestoration = "manual"), 
  {
    set: set,
    get: function(t) {
      return e.get(t);
    },
    has: function(t) {
      return e.has(t);
    },
    capture: function(t) {
      set(t, [ window.scrollX, window.scrollY ]);
    }
  };
}, PopStateEvent = "popstate", HashChangeEvent = "hashchange", getHistoryState = function() {
  try {
    return window.history.state || {};
  } catch (t) {
    return {};
  }
}, createBrowserHistory = function(t) {
  void 0 === t && (t = {}), invariant(canUseDOM, "Browser history needs a DOM");
  var e = window.history, n = supportsHistory(), o = !supportsPopStateOnHashChange(), r = createScrollHistory(), i = null != t.forceRefresh && t.forceRefresh, a = null != t.getUserConfirmation ? t.getUserConfirmation : getConfirmation, s = null != t.keyLength ? t.keyLength : 6, c = t.basename ? stripTrailingSlash(addLeadingSlash(t.basename)) : "", u = function(t) {
    var e = (t = t || {}).key, n = t.state, o = window.location, r = o.pathname + o.search + o.hash;
    return warning(!c || hasBasename(r, c), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + r + '" to begin with "' + c + '".'), 
    c && (r = stripBasename(r, c)), createLocation(r, n, e || createKey(s));
  }, l = createTransitionManager(), h = function(t) {
    r.capture(P.location.key), Object.assign(P, t), P.location.scrollPosition = r.get(P.location.key), 
    P.length = e.length, l.notifyListeners(P.location, P.action);
  }, p = function(t) {
    isExtraneousPopstateEvent(t) || g(u(t.state));
  }, d = function() {
    g(u(getHistoryState()));
  }, f = !1, g = function(t) {
    f ? (f = !1, h()) : l.confirmTransitionTo(t, "POP", a, function(e) {
      e ? h({
        action: "POP",
        location: t
      }) : w(t);
    });
  }, w = function(t) {
    var e = y.indexOf(P.location.key);
    -1 === e && (e = 0);
    var n = y.indexOf(t.key);
    -1 === n && (n = 0);
    var o = e - n;
    o && (f = !0, m(o));
  }, b = u(getHistoryState()), y = [ b.key ], v = function(t) {
    return c + createPath(t);
  }, m = function(t) {
    e.go(t);
  }, S = 0, _ = function(t) {
    1 === (S += t) ? (addEventListener(window, PopStateEvent, p), o && addEventListener(window, HashChangeEvent, d)) : 0 === S && (removeEventListener(window, PopStateEvent, p), 
    o && removeEventListener(window, HashChangeEvent, d));
  }, A = !1, P = {
    length: e.length,
    action: "POP",
    location: b,
    createHref: v,
    push: function(t, o) {
      warning(!("object" == typeof t && void 0 !== t.state && void 0 !== o), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored");
      var r = createLocation(t, o, createKey(s), P.location);
      l.confirmTransitionTo(r, "PUSH", a, function(t) {
        if (t) {
          var o = v(r), a = r.state;
          if (n) if (e.pushState({
            key: r.key,
            state: a
          }, void 0, o), i) window.location.href = o; else {
            var s = y.indexOf(P.location.key), c = y.slice(0, -1 === s ? 0 : s + 1);
            c.push(r.key), y = c, h({
              action: "PUSH",
              location: r
            });
          } else warning(void 0 === a, "Browser history cannot push state in browsers that do not support HTML5 history"), 
          window.location.href = o;
        }
      });
    },
    replace: function(t, o) {
      warning(!("object" == typeof t && void 0 !== t.state && void 0 !== o), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored");
      var r = createLocation(t, o, createKey(s), P.location);
      l.confirmTransitionTo(r, "REPLACE", a, function(t) {
        if (t) {
          var o = v(r), a = r.state;
          if (n) if (e.replaceState({
            key: r.key,
            state: a
          }, void 0, o), i) window.location.replace(o); else {
            var s = y.indexOf(P.location.key);
            -1 !== s && (y[s] = r.key), h({
              action: "REPLACE",
              location: r
            });
          } else warning(void 0 === a, "Browser history cannot replace state in browsers that do not support HTML5 history"), 
          window.location.replace(o);
        }
      });
    },
    go: m,
    goBack: function() {
      return m(-1);
    },
    goForward: function() {
      return m(1);
    },
    block: function(t) {
      void 0 === t && (t = "");
      var e = l.setPrompt(t);
      return A || (_(1), A = !0), function() {
        return A && (A = !1, _(-1)), e();
      };
    },
    listen: function(t) {
      var e = l.appendListener(t);
      return _(1), function() {
        _(-1), e();
      };
    }
  };
  return P;
}, HashChangeEvent$1 = "hashchange", HashPathCoders = {
  hashbang: {
    encodePath: function(t) {
      return "!" === t.charAt(0) ? t : "!/" + stripLeadingSlash(t);
    },
    decodePath: function(t) {
      return "!" === t.charAt(0) ? t.substr(1) : t;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
}, getHashPath = function() {
  var t = window.location.href, e = t.indexOf("#");
  return -1 === e ? "" : t.substring(e + 1);
}, pushHashPath = function(t) {
  return window.location.hash = t;
}, replaceHashPath = function(t) {
  var e = window.location.href.indexOf("#");
  window.location.replace(window.location.href.slice(0, e >= 0 ? e : 0) + "#" + t);
}, createHashHistory = function(t) {
  void 0 === t && (t = {}), invariant(canUseDOM, "Hash history needs a DOM");
  var e = window.history, n = supportsGoWithoutReloadUsingHash(), o = null != t.keyLength ? t.keyLength : 6, r = t.getUserConfirmation, i = void 0 === r ? getConfirmation : r, a = t.hashType, s = void 0 === a ? "slash" : a, c = t.basename ? stripTrailingSlash(addLeadingSlash(t.basename)) : "", u = HashPathCoders[s], l = u.encodePath, h = u.decodePath, p = function() {
    var t = h(getHashPath());
    return warning(!c || hasBasename(t, c), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + t + '" to begin with "' + c + '".'), 
    c && (t = stripBasename(t, c)), createLocation(t, void 0, createKey(o));
  }, d = createTransitionManager(), f = function(t) {
    Object.assign(C, t), C.length = e.length, d.notifyListeners(C.location, C.action);
  }, g = !1, w = null, b = function() {
    var t = getHashPath(), e = l(t);
    if (t !== e) replaceHashPath(e); else {
      var n = p();
      if (!g && locationsAreEqual(C.location, n)) return;
      if (w === createPath(n)) return;
      w = null, y(n);
    }
  }, y = function(t) {
    g ? (g = !1, f()) : d.confirmTransitionTo(t, "POP", i, function(e) {
      e ? f({
        action: "POP",
        location: t
      }) : v(t);
    });
  }, v = function(t) {
    var e = A.lastIndexOf(createPath(C.location));
    -1 === e && (e = 0);
    var n = A.lastIndexOf(createPath(t));
    -1 === n && (n = 0);
    var o = e - n;
    o && (g = !0, P(o));
  }, m = getHashPath(), S = l(m);
  m !== S && replaceHashPath(S);
  var _ = p(), A = [ createPath(_) ], P = function(t) {
    warning(n, "Hash history go(n) causes a full page reload in this browser"), e.go(t);
  }, R = 0, E = function(t) {
    1 === (R += t) ? addEventListener(window, HashChangeEvent$1, b) : 0 === R && removeEventListener(window, HashChangeEvent$1, b);
  }, k = !1, C = {
    length: e.length,
    action: "POP",
    location: _,
    createHref: function(t) {
      return "#" + l(c + createPath(t));
    },
    push: function(t, e) {
      warning(void 0 === e, "Hash history cannot push state; it is ignored");
      var n = createLocation(t, void 0, createKey(o), C.location);
      d.confirmTransitionTo(n, "PUSH", i, function(t) {
        if (t) {
          var e = createPath(n), o = l(c + e);
          if (getHashPath() !== o) {
            w = e, pushHashPath(o);
            var r = A.lastIndexOf(createPath(C.location)), i = A.slice(0, -1 === r ? 0 : r + 1);
            i.push(e), A = i, f({
              action: "PUSH",
              location: n
            });
          } else warning(!1, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack"), 
          f();
        }
      });
    },
    replace: function(t, e) {
      warning(void 0 === e, "Hash history cannot replace state; it is ignored");
      var n = createLocation(t, void 0, createKey(o), C.location);
      d.confirmTransitionTo(n, "REPLACE", i, function(t) {
        if (t) {
          var e = createPath(n), o = l(c + e);
          getHashPath() !== o && (w = e, replaceHashPath(o));
          var r = A.indexOf(createPath(C.location));
          -1 !== r && (A[r] = e), f({
            action: "REPLACE",
            location: n
          });
        }
      });
    },
    go: P,
    goBack: function() {
      return P(-1);
    },
    goForward: function() {
      return P(1);
    },
    block: function(t) {
      void 0 === t && (t = "");
      var e = d.setPrompt(t);
      return k || (E(1), k = !0), function() {
        return k && (k = !1, E(-1)), e();
      };
    },
    listen: function(t) {
      var e = d.appendListener(t);
      return E(1), function() {
        E(-1), e();
      };
    }
  };
  return C;
}, __awaiter$2 = function(t, e, n, o) {
  return new (n || (n = Promise))(function(r, i) {
    function fulfilled(t) {
      try {
        step(o.next(t));
      } catch (t) {
        i(t);
      }
    }
    function rejected(t) {
      try {
        step(o.throw(t));
      } catch (t) {
        i(t);
      }
    }
    function step(t) {
      t.done ? r(t.value) : new n(function(e) {
        e(t.value);
      }).then(fulfilled, rejected);
    }
    step((o = o.apply(t, e || [])).next());
  });
};

function getLocation(t, e) {
  var n = 0 == t.pathname.indexOf(e) ? "/" + t.pathname.slice(e.length) : t.pathname;
  return Object.assign({}, t, {
    pathname: n
  });
}

var HISTORIES = {
  browser: createBrowserHistory,
  hash: createHashHistory
}, Router = /** @class */ function() {
  function Router() {
    var t = this;
    this.root = "/", this.historyType = "browser", this.titleSuffix = "", this.routeViewsUpdated = function(e) {
      if (void 0 === e && (e = {}), e.scrollToId && "browser" === t.historyType) {
        var n = document.getElementById(e.scrollToId);
        if (n) return n.scrollIntoView();
      }
      t.scrollTo(e.scrollTopOffset || t.scrollTopOffset);
    };
  }
  return Router.prototype.componentWillLoad = function() {
    var t = this;
    this.history = HISTORIES[this.historyType](), this.history.listen(function(e) {
      return __awaiter$2(t, void 0, void 0, function() {
        return tslib_1.__generator(this, function(t) {
          return e = getLocation(e, this.root), this.location = e, [ 2 /*return*/ ];
        });
      });
    }), this.location = getLocation(this.history.location, this.root);
  }, Router.prototype.scrollTo = function(t) {
    var e = this;
    if (null != t && !this.isServer && this.history) return "POP" === this.history.action && Array.isArray(this.history.location.scrollPosition) ? this.queue.write(function() {
      e.history && e.history.location && Array.isArray(e.history.location.scrollPosition) && window.scrollTo(e.history.location.scrollPosition[0], e.history.location.scrollPosition[1]);
    }) : this.queue.write(function() {
      window.scrollTo(0, t);
    });
  }, Router.prototype.render = function() {
    if (this.location && this.history) return h(ActiveRouter.Provider, {
      state: {
        historyType: this.historyType,
        location: this.location,
        titleSuffix: this.titleSuffix,
        root: this.root,
        history: this.history,
        routeViewsUpdated: this.routeViewsUpdated
      }
    }, h("slot", null));
  }, Object.defineProperty(Router, "is", {
    get: function() {
      return "stencil-router";
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(Router, "properties", {
    get: function() {
      return {
        history: {
          state: !0
        },
        historyType: {
          type: String,
          attr: "history-type"
        },
        isServer: {
          context: "isServer"
        },
        location: {
          state: !0
        },
        queue: {
          context: "queue"
        },
        root: {
          type: String,
          attr: "root"
        },
        scrollTopOffset: {
          type: Number,
          attr: "scroll-top-offset"
        },
        titleSuffix: {
          type: String,
          attr: "title-suffix"
        }
      };
    },
    enumerable: !0,
    configurable: !0
  }), Router;
}();

export { AppHome, AppRoot, Web3Connector as WebthreeConnector, Route as StencilRoute, RouteSwitch as StencilRouteSwitch, Router as StencilRouter };
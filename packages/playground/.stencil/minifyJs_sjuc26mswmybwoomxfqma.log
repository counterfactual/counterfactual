var __awaiter = this && this.__awaiter || function(e, t, r, n) {
  return new (r || (r = Promise))(function(s, i) {
    function fulfilled(e) {
      try {
        step(n.next(e));
      } catch (e) {
        i(e);
      }
    }
    function rejected(e) {
      try {
        step(n.throw(e));
      } catch (e) {
        i(e);
      }
    }
    function step(e) {
      e.done ? s(e.value) : new r(function(t) {
        t(e.value);
      }).then(fulfilled, rejected);
    }
    step((n = n.apply(e, t || [])).next());
  });
}, __generator = this && this.__generator || function(e, t) {
  var r, n, s, i, a = {
    label: 0,
    sent: function() {
      if (1 & s[0]) throw s[1];
      return s[1];
    },
    trys: [],
    ops: []
  };
  return i = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, "function" == typeof Symbol && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function verb(i) {
    return function(o) {
      return function(i) {
        if (r) throw new TypeError("Generator is already executing.");
        for (;a; ) try {
          if (r = 1, n && (s = 2 & i[0] ? n.return : i[0] ? n.throw || ((s = n.return) && s.call(n), 
          0) : n.next) && !(s = s.call(n, i[1])).done) return s;
          switch (n = 0, s && (i = [ 2 & i[0], s.value ]), i[0]) {
           case 0:
           case 1:
            s = i;
            break;

           case 4:
            return a.label++, {
              value: i[1],
              done: !1
            };

           case 5:
            a.label++, n = i[1], i = [ 0 ];
            continue;

           case 7:
            i = a.ops.pop(), a.trys.pop();
            continue;

           default:
            if (!(s = (s = a.trys).length > 0 && s[s.length - 1]) && (6 === i[0] || 2 === i[0])) {
              a = 0;
              continue;
            }
            if (3 === i[0] && (!s || i[1] > s[0] && i[1] < s[3])) {
              a.label = i[1];
              break;
            }
            if (6 === i[0] && a.label < s[1]) {
              a.label = s[1], s = i;
              break;
            }
            if (s && a.label < s[2]) {
              a.label = s[2], a.ops.push(i);
              break;
            }
            s[2] && a.ops.pop(), a.trys.pop();
            continue;
          }
          i = t.call(e, a);
        } catch (e) {
          i = [ 6, e ], n = 0;
        } finally {
          r = s = 0;
        }
        if (5 & i[0]) throw i[1];
        return {
          value: i[0] ? i[1] : void 0,
          done: !0
        };
      }([ i, o ]);
    };
  }
};

App.loadBundle("/**:bundle-id:**/", [ "exports", "./chunk-346f9d40.js", "./chunk-faed910a.js", "./chunk-f52e57f9.js", "./chunk-cc018d56.js", "./chunk-84817f4c.js" ], function(e, t, r, n, s, i) {
  var a = window.App.h, o = /** @class */ function() {
    function AccountRegister() {
      var e = this;
      this.connected = !1, this.user = {}, this.updateAccount = function(e) {}, this.signer = {}, 
      this.history = {}, this.metamaskUnlocked = !1, this.waitForMultisig = function() {
        return __awaiter(e, void 0, void 0, function() {
          return __generator(this, function(e) {
            return [ 2 /*return*/ ];
          });
        });
      }, this.changeset = {
        username: "",
        email: "",
        ethAddress: this.user.ethAddress,
        nodeAddress: n.CounterfactualNode.getInstance().publicIdentifier
      }, this.errors = {
        username: "",
        email: "",
        ethAddress: "",
        nodeAddress: ""
      }, this.stage = "ready";
    }
    return AccountRegister.prototype.componentDidUpdate = function() {
      this.metamaskUnlocked || this.history.push("/");
    }, AccountRegister.prototype.login = function(e) {
      return __awaiter(this, void 0, void 0, function() {
        var t, r;
        return __generator(this, function(n) {
          switch (n.label) {
           case 0:
            return e.preventDefault(), [ 4 /*yield*/ , this.signer.signMessage((s = this.user.ethAddress, 
            [ "PLAYGROUND ACCOUNT LOGIN", "Ethereum address: " + s ].join("\n"))) ];

           case 1:
            return t = n.sent(), [ 4 /*yield*/ , i.PlaygroundAPIClient.login({
              ethAddress: this.user.ethAddress
            }, t) ];

           case 2:
            return r = n.sent(), window.localStorage.setItem("playground:user:token", r.token), 
            this.updateAccount({
              user: r
            }), this.history.push("/"), [ 2 /*return*/ ];
          }
          var s;
        });
      });
    }, AccountRegister.prototype.change = function(e, t) {
      this.changeset[e] = t.target.value;
    }, AccountRegister.prototype.formSubmissionHandler = function() {
      return __awaiter(this, void 0, void 0, function() {
        var e, t, r;
        return __generator(this, function(n) {
          switch (n.label) {
           case 0:
            this.clearErrorMessage(), e = function(e) {
              return [ "PLAYGROUND ACCOUNT REGISTRATION", "Username: " + e.username, "E-mail: " + e.email, "Ethereum address: " + e.ethAddress, "Node address: " + e.nodeAddress ].join("\n");
            }(this.changeset), this.stage = "awaitingForWallet", n.label = 1;

           case 1:
            return n.trys.push([ 1, 4, , 5 ]), [ 4 /*yield*/ , this.signer.signMessage(e) ];

           case 2:
            return t = n.sent(), [ 4 /*yield*/ , this.register(t) ];

           case 3:
            return n.sent(), [ 3 /*break*/ , 5 ];

           case 4:
            return r = n.sent(), this.handleMetamaskErrors(r), this.stage = "ready", [ 3 /*break*/ , 5 ];

           case 5:
            return [ 2 /*return*/ ];
          }
        });
      });
    }, AccountRegister.prototype.handleMetamaskErrors = function(e) {
      e.message.match(/User denied message signature/) && this.setErrorMessage("user_denied_signature");
    }, AccountRegister.prototype.onUserUpdated = function() {
      this.user.multisigAddress && "deployingMultisig" === this.stage && (this.stage = "finished");
    }, AccountRegister.prototype.register = function(e) {
      return __awaiter(this, void 0, void 0, function() {
        var t, r;
        return __generator(this, function(n) {
          switch (n.label) {
           case 0:
            return n.trys.push([ 0, 2, , 3 ]), this.stage = "creatingAccount", [ 4 /*yield*/ , i.PlaygroundAPIClient.createAccount(this.changeset, e) ];

           case 1:
            return t = n.sent(), this.updateAccount({
              user: t
            }), window.localStorage.setItem("playground:user:token", t.token), ga("set", "userId", t.id), 
            this.stage = "deployingMultisig", this.waitForMultisig(), [ 3 /*break*/ , 3 ];

           case 2:
            return r = n.sent(), this.setErrorMessage(r.code), this.stage = "ready", [ 3 /*break*/ , 3 ];

           case 3:
            return [ 2 /*return*/ ];
          }
        });
      });
    }, AccountRegister.prototype.clearErrorMessage = function() {
      this.errors = {
        username: "",
        email: "",
        ethAddress: "",
        nodeAddress: ""
      };
    }, AccountRegister.prototype.setErrorMessage = function(e) {
      var t = {};
      switch (this.clearErrorMessage(), e) {
       case "username_required":
        t = {
          username: "This field is required"
        };
        break;

       case "username_already_exists":
        t = {
          username: "This username is not available, try another one."
        };
        break;

       case "email_required":
        t = {
          email: "This field is required"
        };
        break;

       case "signature_required":
        t = {
          ethAddress: "You must sign the operation with Metamask in order to continue"
        };
        break;

       case "invalid_signature":
        t = {
          ethAddress: "Something went wrong with your signature. Please try again."
        };
        break;

       case "address_already_registered":
        t = {
          ethAddress: "Cannot use same ethereum address twice."
        };
        break;

       case "user_save_failed":
        t = {
          ethAddress: "Something went wrong while saving your data. Please try again later."
        };
        break;

       case "user_denied_signature":
        t = {
          ethAddress: "You must approve the message signature at Metamask in order to proceed."
        };
      }
      this.errors = Object.assign({}, this.errors, t);
    }, AccountRegister.prototype.render = function() {
      var e = this;
      if ("finished" === this.stage) return a("stencil-router-redirect", {
        url: "/deposit"
      });
      this.user.ethAddress && (this.changeset.ethAddress = this.user.ethAddress);
      var t = "ready" !== this.stage, r = a("div", {
        slot: "post"
      }, "Already have an account?", " ", a("a", {
        href: "#",
        onClick: function(t) {
          return __awaiter(e, void 0, void 0, function() {
            return __generator(this, function(e) {
              switch (e.label) {
               case 0:
                return [ 4 /*yield*/ , this.login(t) ];

               case 1:
                return [ 2 /*return*/ , e.sent() ];
              }
            });
          });
        }
      }, "Login here"));
      return "deployingMultisig" === this.stage && (r = a("div", {
        slot: "post"
      }, a("b", null, "This can take around 15-90 seconds."), a("br", null), "Please be patient! :)")), 
      a("widget-screen", {
        exitable: !t
      }, a("div", {
        slot: "header"
      }, "Create a Playground Account"), a("form-container", {
        onFormSubmitted: function(t) {
          return __awaiter(e, void 0, void 0, function() {
            return __generator(this, function(e) {
              switch (e.label) {
               case 0:
                return [ 4 /*yield*/ , this.formSubmissionHandler() ];

               case 1:
                return [ 2 /*return*/ , e.sent() ];
              }
            });
          });
        }
      }, a("form-input", {
        disabled: t,
        label: "Username",
        value: this.changeset.username,
        error: this.errors.username,
        autofocus: !0,
        onChange: function(t) {
          return e.change("username", t);
        }
      }), a("form-input", {
        disabled: t,
        label: "Email (optional)",
        value: this.changeset.email,
        error: this.errors.email,
        onChange: function(t) {
          return e.change("email", t);
        }
      }), a("div", {
        class: "smallprint"
      }, a("b", null, "Account will be linked to your Ethereum address: "), this.changeset.ethAddress), a("div", {
        class: "error"
      }, this.errors.ethAddress), a("form-button", {
        class: "button",
        disabled: t,
        spinner: t,
        onButtonPressed: function(t) {
          return __awaiter(e, void 0, void 0, function() {
            return __generator(this, function(e) {
              switch (e.label) {
               case 0:
                return [ 4 /*yield*/ , this.formSubmissionHandler() ];

               case 1:
                return [ 2 /*return*/ , e.sent() ];
              }
            });
          });
        }
      }, {
        ready: "Register",
        awaitingForWallet: "Check Wallet...",
        creatingAccount: "Creating your account...",
        deployingMultisig: "Deploying contract..."
      }[this.stage])), r);
    }, Object.defineProperty(AccountRegister, "is", {
      get: function() {
        return "account-register";
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(AccountRegister, "encapsulation", {
      get: function() {
        return "shadow";
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(AccountRegister, "properties", {
      get: function() {
        return {
          connected: {
            type: Boolean,
            attr: "connected"
          },
          el: {
            elementRef: !0
          },
          errors: {
            state: !0
          },
          history: {
            type: "Any",
            attr: "history"
          },
          metamaskUnlocked: {
            type: Boolean,
            attr: "metamask-unlocked"
          },
          signer: {
            type: "Any",
            attr: "signer"
          },
          stage: {
            state: !0
          },
          updateAccount: {
            type: "Any",
            attr: "update-account"
          },
          user: {
            type: "Any",
            attr: "user",
            watchCallbacks: [ "onUserUpdated" ]
          },
          waitForMultisig: {
            type: "Any",
            attr: "wait-for-multisig"
          }
        };
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(AccountRegister, "style", {
      get: function() {
        return "/**style-placeholder:account-register:**/";
      },
      enumerable: !0,
      configurable: !0
    }), AccountRegister;
  }();
  r.AccountTunnel.injectProps(o, [ "updateAccount", "user", "waitForMultisig" ]), 
  s.WalletTunnel.injectProps(o, [ "connected", "signer", "metamaskUnlocked" ]), e.AccountRegister = o, 
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
});
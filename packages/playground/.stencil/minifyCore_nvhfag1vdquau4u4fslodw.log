/**
 * SSR Attribute Names
 */
function getScopeId(t, n) {
  return "sc-" + t._$tagNameMeta$_ + (n && n !== e ? "-" + n : "");
}

function getElementScopeId(e, t) {
  return e + (t ? "-h" : "-s");
}

function h$1(e, t) {
  let n, o, l = null, i = !1, s = !1, a = arguments.length;
  for (;a-- > 2; ) y.push(arguments[a]);
  for (;y.length > 0; ) {
    let t = y.pop();
    if (t && void 0 !== t.pop) for (a = t.length; a--; ) y.push(t[a]); else "boolean" == typeof t && (t = null), 
    (s = "function" != typeof e) && (null == t ? t = "" : "number" == typeof t ? t = String(t) : "string" != typeof t && (s = !1)), 
    s && i ? l[l.length - 1].vtext += t : null === l ? l = [ s ? {
      vtext: t
    } : t ] : l.push(s ? {
      vtext: t
    } : t), i = s;
  }
  if (null != t) {
    if (
    // normalize class / classname attributes
    t.className && (t.class = t.className), "object" == typeof t.class) {
      for (a in t.class) t.class[a] && y.push(a);
      t.class = y.join(" "), y.length = 0;
    }
    null != t.key && (n = t.key), null != t.name && (o = t.name);
  }
  return "function" == typeof e ? e(t, l || [], g) : {
    vtag: e,
    vchildren: l,
    vtext: void 0,
    vattrs: t,
    vkey: n,
    vname: o,
    _$elm$_: void 0,
    _$ishost$_: !1
  };
}

const e = "$", t = {}, o = {
  enter: 13,
  escape: 27,
  space: 32,
  tab: 9,
  left: 37,
  up: 38,
  right: 39,
  down: 40
}, l = (t, n, o, l) => {
  // first see if we've got a style for a specific mode
  // either this host element should use scoped css
  // or it wants to use shadow dom but the browser doesn't support it
  // create a scope id which is useful for scoped css
  // and add the scope attribute to the host
  // create the style id w/ the host element's mode
  let i = o._$tagNameMeta$_ + e, s = o[i];
  if ((2 /* ScopedCss */ === o._$encapsulationMeta$_ || 1 /* ShadowDom */ === o._$encapsulationMeta$_ && !t._$domApi$_._$$supportsShadowDom$_) && (l["s-sc"] = s ? getScopeId(o, l.mode) : getScopeId(o)), 
  s) {
    // cool, we found a style template element for this component
    let e = n._$$doc$_.head;
    // if this browser supports shadow dom, then let's climb up
    // the dom and see if we're within a shadow dom
        if (n._$$supportsShadowDom$_) if (1 /* ShadowDom */ === o._$encapsulationMeta$_) 
    // we already know we're in a shadow dom
    // so shadow root is the container for these styles
    e = l.shadowRoot; else {
      // climb up the dom and see if we're in a shadow dom
      const t = l.getRootNode();
      t.host && (e = t);
    }
    // if this container element already has these styles
    // then there's no need to apply them again
    // create an object to keep track if we'ready applied this component style
        let a = t._$componentAppliedStyles$_.get(e);
    // check if we haven't applied these styles to this container yet
    if (a || t._$componentAppliedStyles$_.set(e, a = {}), !a[i]) {
      let t;
      {
        // this browser supports the <template> element
        // and all its native content.cloneNode() goodness
        // clone the template element to create a new <style> element
        t = s.content.cloneNode(!0), 
        // remember we don't need to do this again for this element
        a[i] = !0;
        // let's make sure we put the styles below the <style data-styles> element
        // so any visibility css overrides the default
        const o = e.querySelectorAll("[data-styles]");
        n._$$insertBefore$_(e, t, o.length && o[o.length - 1].nextSibling || e.firstChild);
      }
    }
  }
}, i = e => null != e, s = e => e.toLowerCase(), a = (e, t, n, o, l, i) => {
  if ("class" !== n || i) if ("style" === n) {
    for (const e in o) l && null != l[e] || (/-/.test(e) ? t.style.removeProperty(e) : t.style[e] = "");
    for (const e in l) o && l[e] === o[e] || (/-/.test(e) ? t.style.setProperty(e, l[e]) : t.style[e] = l[e]);
  } else if ("o" !== n[0] || "n" !== n[1] || !/[A-Z]/.test(n[2]) || n in t) if ("list" !== n && "type" !== n && !i && (n in t || -1 !== [ "object", "function" ].indexOf(typeof l) && null !== l)) {
    // Properties
    // - list and type are attributes that get applied as values on the element
    // - all svgs get values as attributes not props
    // - check if elm contains name or if the value is array, object, or function
    const o = e._$getComponentMeta$_(t);
    o && o._$membersMeta$_ && o._$membersMeta$_[n] ? 
    // we know for a fact that this element is a known component
    // and this component has this member name as a property,
    // let's set the known @Prop on this element
    // set it directly as property on the element
    p(t, n, l) : "ref" !== n && (
    // this member name is a property on this element, but it's not a component
    // this is a native property like "value" or something
    // also we can ignore the "ref" member name at this point
    p(t, n, null == l ? "" : l), null != l && !1 !== l || e._$domApi$_._$$removeAttribute$_(t, n));
  } else null != l && "key" !== n ? 
  // Element Attributes
  ((e, t, n, o = "boolean" == typeof n, l) => {
    l = t !== (t = t.replace(/^xlink\:?/, "")), null == n || o && (!n || "false" === n) ? l ? e.removeAttributeNS("http://www.w3.org/1999/xlink", s(t)) : e.removeAttribute(t) : "function" != typeof n && (n = o ? "" : n.toString(), 
    l ? e.setAttributeNS("http://www.w3.org/1999/xlink", s(t), n) : e.setAttribute(t, n));
  })(t, n, l) : (i || e._$domApi$_._$$hasAttribute$_(t, n) && (null == l || !1 === l)) && 
  // remove svg attribute
  e._$domApi$_._$$removeAttribute$_(t, n); else 
  // Event Handlers
  // so if the member name starts with "on" and the 3rd characters is
  // a capital letter, and it's not already a member on the element,
  // then we're assuming it's an event listener
  // standard event
  // the JSX attribute could have been "onMouseOver" and the
  // member name "onmouseover" is on the element's prototype
  // so let's add the listener "mouseover", which is all lowercased
  n = s(n) in t ? s(n.substring(2)) : s(n[2]) + n.substring(3), l ? l !== o && 
  // add listener
  e._$domApi$_._$$addEventListener$_(t, n, l, 0) : 
  // remove listener
  e._$domApi$_._$$removeEventListener$_(t, n, 0); else if (o !== l) {
    const e = f(o), n = f(l), i = e.filter(e => !n.includes(e)), s = f(t.className).filter(e => !i.includes(e)), a = n.filter(t => !e.includes(t) && !s.includes(t));
    s.push(...a), t.className = s.join(" ");
  }
}, f = e => null == e || "" === e ? [] : e.trim().split(/\s+/), p = (e, t, n) => {
  try {
    e[t] = n;
  } catch (e) {}
}, u = (e, n, o, l, i) => {
  // if the element passed in is a shadow root, which is a document fragment
  // then we want to be adding attrs/props to the shadow root's "host" element
  // if it's not a shadow root, then we add attrs/props to the same element
  const s = 11 /* DocumentFragment */ === o._$elm$_.nodeType && o._$elm$_.host ? o._$elm$_.host : o._$elm$_, r = n && n.vattrs || t, c = o.vattrs || t;
  // remove attributes no longer present on the vnode by setting them to undefined
  for (i in r) c && null != c[i] || null == r[i] || a(e, s, i, r[i], void 0, l, o._$ishost$_);
  // add new & update changed attributes
  for (i in c) i in r && c[i] === ("value" === i || "checked" === i ? s[i] : r[i]) || a(e, s, i, r[i], c[i], l, o._$ishost$_);
};

let m = !1;

const b = (e, t) => {
  e && (e.vattrs && e.vattrs.ref && e.vattrs.ref(t ? null : e._$elm$_), e.vchildren && e.vchildren.forEach(e => {
    b(e, t);
  }));
}, v = (e, t) => {
  {
    let n = 0, o = !1;
    const l = () => t.performance.now(), i = !1 !== e.asyncQueue, s = Promise.resolve(), a = [], r = [], c = [], f = [], p = t => n => {
      // queue dom reads
      t.push(n), o || (o = !0, e.raf(m));
    }, u = e => {
      for (let t = 0; t < e.length; t++) try {
        e[t](l());
      } catch (e) {
        console.error(e);
      }
      e.length = 0;
    }, d = (e, t) => {
      let n, o = 0;
      for (;o < e.length && (n = l()) < t; ) try {
        e[o++](n);
      } catch (e) {
        console.error(e);
      }
      o === e.length ? e.length = 0 : 0 !== o && e.splice(0, o);
    }, m = () => {
      n++, 
      // always force a bunch of medium callbacks to run, but still have
      // a throttle on how many can run in a certain time
      // DOM READS!!!
      u(r);
      const t = i ? l() + 7 * Math.ceil(n * (1 / 22)) : Infinity;
      // DOM WRITES!!!
            d(c, t), d(f, t), c.length > 0 && (f.push(...c), c.length = 0), (o = r.length + c.length + f.length > 0) ? 
      // still more to do yet, but we've run out of time
      // let's let this thing cool off and try again in the next tick
      e.raf(m) : n = 0;
    };
    return e.raf || (e.raf = t.requestAnimationFrame.bind(t)), {
      tick(e) {
        // queue high priority work to happen in next tick
        // uses Promise.resolve() for next tick
        a.push(e), 1 === a.length && s.then(() => u(a));
      },
      read: p(r),
      write: p(c)
    };
  }
}, y = [], g = {
  forEach: (e, t) => e.forEach(t),
  map: (e, t) => e.map(t)
}, $ = (e, t, n) => {
  // tag name will always be lower case
  // parse member meta
  // this data only includes props that are attributes that need to be observed
  // it does not include all of the props yet
  const [o, l, , i, s, a] = e, r = {
    // every component defaults to always have
    // the mode and color properties
    // but only color should observe any attribute changes
    color: {
      _$attribName$_: "color"
    }
  };
  if (i) for (t = 0; t < i.length; t++) r[(n = i[t])[0]] = {
    _$memberType$_: n[1],
    _$reflectToAttrib$_: !!n[2],
    _$attribName$_: "string" == typeof n[3] ? n[3] : n[3] ? n[0] : 0,
    _$propType$_: n[4]
  };
  return {
    _$tagNameMeta$_: o,
    // map of the bundle ids
    // can contain modes, and array of esm and es5 bundle ids
    _$bundleIds$_: l,
    _$membersMeta$_: Object.assign({}, r),
    // encapsulation
    _$encapsulationMeta$_: s,
    // parse listener meta
    _$listenersMeta$_: a ? a.map(M) : void 0
  };
}, M = e => ({
  _$eventName$_: e[0],
  _$eventMethodName$_: e[1],
  _$eventDisabled$_: !!e[2],
  _$eventPassive$_: !!e[3],
  _$eventCapture$_: !!e[4]
}), k = (e, t) => 
// ensure this value is of the correct prop type
// we're testing both formats of the "propType" value because
// we could have either gotten the data from the attribute changed callback,
// which wouldn't have Constructor data yet, and because this method is reused
// within proxy where we don't have meta data, but only constructor data
i(t) && "object" != typeof t && "function" != typeof t ? e === Boolean || 4 /* Boolean */ === e ? "false" !== t && ("" === t || !!t) : e === Number || 8 /* Number */ === e ? parseFloat(t) : e === String || 2 /* String */ === e ? t.toString() : t : t, C = (e, t, n) => {
  // we're actively processing this component
  e._$processingCmp$_.add(t), 
  // only run patch if it isn't queued already
  e._$isQueuedForUpdate$_.has(t) || (e._$isQueuedForUpdate$_.set(t, !0), 
  // run the patch in the next tick
  // vdom diff and patch the host element for differences
  e._$isAppLoaded$_ ? 
  // app has already loaded
  // let's queue this work in the dom write phase
  e.queue.write(() => S(e, t, n)) : 
  // app hasn't finished loading yet
  // so let's use next tick to do everything
  // as fast as possible
  e.queue.tick(() => S(e, t, n)));
}, S = async (e, t, n, o, l, i) => {
  // everything is async, so somehow we could have already disconnected
  // this node, so be sure to do nothing if we've already disconnected
  if (
  // no longer queued for update
  e._$isQueuedForUpdate$_.delete(t), !e._$isDisconnectedMap$_.has(t)) {
    if (!(l = e._$instanceMap$_.get(t))) {
      if ((i = e._$ancestorHostElementMap$_.get(t)) && !i["s-rn"]) 
      // this is the intial load
      // this element has an ancestor host element
      // but the ancestor host element has NOT rendered yet
      // so let's just cool our jets and wait for the ancestor to render
      return void (i["s-rc"] = i["s-rc"] || []).push(() => {
        // this will get fired off when the ancestor host element
        // finally gets around to rendering its lazy self
        S(e, t, n);
      });
      // haven't created a component instance for this host element yet!
      // create the instance from the user's component class
      // https://www.youtube.com/watch?v=olLxrojmvMg
            if (l = A(e, t, e._$hostSnapshotMap$_.get(t), n)) 
      // this is the initial load and the instance was just created
      // fire off the user's componentWillLoad method (if one was provided)
      // componentWillLoad only runs ONCE, after instance's element has been
      // assigned as the host element, but BEFORE render() has been called
      try {
        l.componentWillLoad && await l.componentWillLoad();
      } catch (n) {
        e._$onError$_(n, 3 /* WillLoadError */ , t);
      }
    }
    // if this component has a render function, let's fire
    // it off and generate a vnode for this
        ((e, t, n, o) => {
      try {
        // if this component has a render function, let's fire
        // it off and generate the child vnodes for this host element
        // note that we do not create the host element cuz it already exists
        const l = t._$componentConstructor$_.host, i = t._$componentConstructor$_.encapsulation, s = "shadow" === i && e._$domApi$_._$$supportsShadowDom$_;
        let a, r = n;
        if (
        // this component SHOULD use native slot/shadow dom
        // this browser DOES support native shadow dom
        // and this is the first render
        // let's create that shadow root
        // test if this component should be shadow dom
        // and if so does the browser supports it
        s && (r = n.shadowRoot), !n["s-rn"]) {
          // attach the styles this component needs, if any
          // this fn figures out if the styles should go in a
          // shadow root or if they should be global
          e._$attachStyles$_(e, e._$domApi$_, t, n);
          const o = n["s-sc"];
          o && (e._$domApi$_._$$addClass$_(n, getElementScopeId(o, !0)), "scoped" === i && e._$domApi$_._$$addClass$_(n, getElementScopeId(o)));
        }
        if (o.render || o.hostData || l || a) {
          // tell the platform we're actively rendering
          // if a value is changed within a render() then
          // this tells the platform not to queue the change
          e._$activeRender$_ = !0;
          const t = o.render && o.render();
          let l;
          // tell the platform we're done rendering
          // now any changes will again queue
          e._$activeRender$_ = !1;
          // looks like we've got child nodes to render into this host element
          // or we need to update the css class/attrs on the host element
          const a = h$1(null, l, t), c = e._$vnodeMap$_.get(n) || {};
          // if we haven't already created a vnode, then we give the renderer the actual element
          // if this is a re-render, then give the renderer the last vnode we already created
                    c._$elm$_ = r, 
          // each patch always gets a new vnode
          // the host element itself isn't patched because it already exists
          // kick off the actual render and any DOM updates
          e._$vnodeMap$_.set(n, e.render(n, c, a, s, i));
        }
        // update styles!
                // it's official, this element has rendered
        n["s-rn"] = !0, n["s-rc"] && (
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        n["s-rc"].forEach(e => e()), n["s-rc"] = null);
      } catch (t) {
        e._$activeRender$_ = !1, e._$onError$_(t, 8 /* RenderError */ , n, !0);
      }
    })(e, e._$getComponentMeta$_(t), t, l), t["s-init"]();
  }
}, E = (e, t, n, o, l, s, a, r, c) => {
  if (t.type || t.state) {
    const f = e._$valuesMap$_.get(n);
    t.state || (!t.attr || void 0 !== f[l] && "" !== f[l] || 
    // check the prop value from the host element attribute
    (r = s && s._$$attributes$_) && i(c = r[t.attr]) && (
    // looks like we've got an attribute value
    // let's set it to our internal values
    f[l] = k(t.type, c)), 
    // client-side
    // within the browser, the element's prototype
    // already has its getter/setter set, but on the
    // server the prototype is shared causing issues
    // so instead the server's elm has the getter/setter
    // directly on the actual element instance, not its prototype
    // so on the browser we can use "hasOwnProperty"
    n.hasOwnProperty(l) && (
    // @Prop or @Prop({mutable:true})
    // property values on the host element should override
    // any default values on the component instance
    void 0 === f[l] && (f[l] = k(t.type, n[l])), 
    // for the client only, let's delete its "own" property
    // this way our already assigned getter/setter on the prototype kicks in
    // the very special case is to NOT do this for "mode"
    "mode" !== l && delete n[l])), o.hasOwnProperty(l) && void 0 === f[l] && (
    // @Prop() or @Prop({mutable:true}) or @State()
    // we haven't yet got a value from the above checks so let's
    // read any "own" property instance values already set
    // to our internal value as the source of getter data
    // we're about to define a property and it'll overwrite this "own" property
    f[l] = o[l]), t.watchCallbacks && (f[O + l] = t.watchCallbacks.slice()), 
    // add getter/setter to the component instance
    // these will be pointed to the internal data set from the above checks
    N(o, l, function getComponentProp(t) {
      // component instance prop/state getter
      // get the property value directly from our internal values
      return (t = e._$valuesMap$_.get(e._$hostElementMap$_.get(this))) && t[l];
    }, function setComponentProp(n, o) {
      // component instance prop/state setter (cannot be arrow fn)
      (o = e._$hostElementMap$_.get(this)) && (t.state || t.mutable) && j(e, o, l, n, a);
    });
  } else if (t.elementRef) 
  // @Element()
  // add a getter to the element reference using
  // the member name the component meta provided
  W(o, l, n); else if (t.context) {
    // @Prop({ context: 'config' })
    const i = e._$getContextItem$_(t.context);
    void 0 !== i && W(o, l, i.getContext && i.getContext(n) || i);
  }
}, j = (e, t, n, o, l, i, s) => {
  (
  // get the internal values object, which should always come from the host element instance
  // create the _values object if it doesn't already exist
  s = e._$valuesMap$_.get(t)) || e._$valuesMap$_.set(t, s = {});
  const a = s[n];
  // check our new property value against our internal value
    if (o !== a && (
  // gadzooks! the property's value has changed!!
  // set our new value!
  // https://youtu.be/dFtLONl4cNc?t=22
  s[n] = o, i = e._$instanceMap$_.get(t))) {
    {
      const e = s[O + n];
      if (e) 
      // this instance is watching for when this property changed
      for (let t = 0; t < e.length; t++) try {
        // fire off each of the watch methods that are watching this property
        i[e[t]].call(i, o, a, n);
      } catch (e) {
        console.error(e);
      }
    }
    !e._$activeRender$_ && t["s-rn"] && 
    // looks like this value actually changed, so we've got work to do!
    // but only if we've already rendered, otherwise just chill out
    // queue that we need to do an update, but don't worry about queuing
    // up millions cuz this function ensures it only runs once
    C(e, t, l);
  }
}, W = (e, t, n) => {
  // minification shortcut
  Object.defineProperty(e, t, {
    configurable: !0,
    value: n
  });
}, N = (e, t, n, o) => {
  // minification shortcut
  Object.defineProperty(e, t, {
    configurable: !0,
    get: n,
    set: o
  });
}, O = "wc-", A = (e, t, n, o, l, i) => {
  try {
    l = new (
    // using the user's component class, let's create a new instance
    i = e._$getComponentMeta$_(t)._$componentConstructor$_)(), 
    // ok cool, we've got an host element now, and a actual instance
    // and there were no errors creating the instance
    // let's upgrade the data on the host element
    // and let the getters/setters do their jobs
    ((e, t, n, o, l, i) => {
      // at this point we've got a specific node of a host element, and created a component class instance
      // and we've already created getters/setters on both the host element and component class prototypes
      // let's upgrade any data that might have been set on the host element already
      // and let's have the getters/setters kick in and do their jobs
      // let's automatically add a reference to the host element on the instance
      e._$hostElementMap$_.set(o, n), 
      // create the values object if it doesn't already exist
      // this will hold all of the internal getter/setter values
      e._$valuesMap$_.has(n) || e._$valuesMap$_.set(n, {}), 
      // get the properties from the constructor
      // and add default "mode" and "color" properties
      Object.entries(Object.assign({
        color: {
          type: String
        }
      }, t.properties, {
        mode: {
          type: String
        }
      })).forEach(([t, s]) => {
        // define each of the members and initialize what their role is
        E(e, s, n, o, t, l, i);
      });
    })(e, i, t, l, n, o), 
    // add each of the event emitters which wire up instance methods
    // to fire off dom events from the host element
    function initEventEmitters(e, t, n) {
      if (t) {
        const o = e._$hostElementMap$_.get(n);
        t.forEach(t => {
          n[t.method] = {
            emit: n => e._$emitEvent$_(o, t.name, {
              bubbles: t.bubbles,
              composed: t.composed,
              cancelable: t.cancelable,
              detail: n
            })
          };
        });
      }
    }(e, i.events, l);
  } catch (n) {
    // something done went wrong trying to create a component instance
    // create a dumby instance so other stuff can load
    // but chances are the app isn't fully working cuz this component has issues
    l = {}, e._$onError$_(n, 7 /* InitInstanceError */ , t, !0);
  }
  return e._$instanceMap$_.set(t, l), l;
}, T = (e, t, n, o, l, i) => {
  if (
  // we're no longer processing this component
  e._$processingCmp$_.delete(t), 
  // load events fire from bottom to top
  // the deepest elements load first then bubbles up
  (l = e._$ancestorHostElementMap$_.get(t)) && (
  // ok so this element already has a known ancestor host element
  // let's make sure we remove this element from its ancestor's
  // known list of child elements which are actively loading
  (o = l["s-ld"]) && ((n = o.indexOf(t)) > -1 && 
  // yup, this element is in the list of child elements to wait on
  // remove it so we can work to get the length down to 0
  o.splice(n, 1), 
  // the ancestor's initLoad method will do the actual checks
  // to see if the ancestor is actually loaded or not
  // then let's call the ancestor's initLoad method if there's no length
  // (which actually ends up as this method again but for the ancestor)
  o.length || l["s-init"] && l["s-init"]()), e._$ancestorHostElementMap$_.delete(t)), 
  e._$onAppReadyCallbacks$_.length && !e._$processingCmp$_.size) 
  // we've got some promises waiting on the entire app to be done processing
  // so it should have an empty queue and no longer rendering
  for (;i = e._$onAppReadyCallbacks$_.shift(); ) i();
}, I = (e, t, n, o) => {
  t.forEach(([t, l]) => {
    3 /* PropMutable */ & l._$memberType$_ && 
    // @Prop() or @Prop({ mutable: true })
    N(n, t, function getHostElementProp() {
      // host element getter (cannot be arrow fn)
      // yup, ugly, srynotsry
      return (e._$valuesMap$_.get(this) || {})[t];
    }, function setHostElementProp(n) {
      // host element setter (cannot be arrow fn)
      j(e, this, t, k(l._$propType$_, n), o);
    });
  });
}, P = (e, t, n, o, l) => {
  if (
  // let's wire up our functions to the host element's prototype
  // we can also inject our platform into each one that needs that api
  // note: these cannot be arrow functions cuz "this" is important here hombre
  n.connectedCallback = function() {
    // coolsville, our host element has just hit the DOM
    ((e, t, n) => {
      // this element just connected, which may be re-connecting
      // ensure we remove it from our map of disconnected
      e._$isDisconnectedMap$_.delete(n), e._$hasConnectedMap$_.has(n) || (e._$hasConnectedComponent$_ = !0, 
      e._$processingCmp$_.add(n), 
      // first time we've connected
      e._$hasConnectedMap$_.set(n, !0), 
      // register this component as an actively
      // loading child to its parent component
      ((e, t, n) => {
        for (
        // find the first ancestor host element (if there is one) and register
        // this element as one of the actively loading child elements for its ancestor
        n = t; n = e._$domApi$_._$$parentElement$_(n); ) 
        // climb up the ancestors looking for the first registered component
        if (e._$isDefinedComponent$_(n)) {
          // we found this elements the first ancestor host element
          // if the ancestor already loaded then do nothing, it's too late
          e._$isCmpReady$_.has(t) || (
          // keep a reference to this element's ancestor host element
          // elm._ancestorHostElement = ancestorHostElement;
          e._$ancestorHostElementMap$_.set(t, n), 
          // ensure there is an array to contain a reference to each of the child elements
          // and set this element as one of the ancestor's child elements it should wait on
          (n["s-ld"] = n["s-ld"] || []).push(t));
          break;
        }
      })(e, n), 
      // add to the queue to load the bundle
      // it's important to have an async tick in here so we can
      // ensure the "mode" attribute has been added to the element
      // place in high priority since it's not much work and we need
      // to know as fast as possible, but still an async tick in between
      e.queue.tick(() => {
        // start loading this component mode's bundle
        // if it's already loaded then the callback will be synchronous
        e._$hostSnapshotMap$_.set(n, ((e, t, n, o, l) => (
        // the host element has connected to the dom
        // and we've waited a tick to make sure all frameworks
        // have finished adding attributes and child nodes to the host
        // before we go all out and hydrate this beast
        // let's first take a snapshot of its original layout before render
        n.mode || (
        // looks like mode wasn't set as a property directly yet
        // first check if there's an attribute
        // next check the app's global
        n.mode = e._$$getMode$_(n)), 
        // if the slot polyfill is required we'll need to put some nodes
        // in here to act as original content anchors as we move nodes around
        // host element has been connected to the DOM
        n["s-cr"] || e._$$getAttribute$_(n, "ssrv") || e._$$supportsShadowDom$_ && 1 /* ShadowDom */ === t._$encapsulationMeta$_ || (
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        n["s-cr"] = e._$$createTextNode$_(""), n["s-cr"]["s-cn"] = !0, e._$$insertBefore$_(n, n["s-cr"], e._$$childNodes$_(n)[0])), 
        1 /* ShadowDom */ === t._$encapsulationMeta$_ && e._$$supportsShadowDom$_ && !n.shadowRoot && 
        // this component is using shadow dom
        // and this browser supports shadow dom
        // add the read-only property "shadowRoot" to the host element
        e._$$attachShadow$_(n, {
          mode: "open"
        }), 
        // create a host snapshot object we'll
        // use to store all host data about to be read later
        o = {
          _$$attributes$_: {}
        }, 
        // loop through and gather up all the original attributes on the host
        // this is useful later when we're creating the component instance
        t._$membersMeta$_ && Object.keys(t._$membersMeta$_).forEach(i => {
          (l = t._$membersMeta$_[i]._$attribName$_) && (o._$$attributes$_[l] = e._$$getAttribute$_(n, l));
        }), o))(e._$domApi$_, t, n)), e._$requestBundle$_(t, n);
      }));
    })(e, t, this);
  }, n.disconnectedCallback = function() {
    // the element has left the builing
    ((e, t) => {
      // only disconnect if we're not temporarily disconnected
      // tmpDisconnected will happen when slot nodes are being relocated
      if (!e._$tmpDisconnected$_ && ((e, t) => {
        for (;t; ) {
          if (!e._$$parentNode$_(t)) return 9 /* DocumentNode */ !== e._$$nodeType$_(t);
          t = e._$$parentNode$_(t);
        }
      })(e._$domApi$_, t)) {
        // ok, let's officially destroy this thing
        // set this to true so that any of our pending async stuff
        // doesn't continue since we already decided to destroy this node
        // elm._hasDestroyed = true;
        e._$isDisconnectedMap$_.set(t, !0), 
        // double check that we've informed the ancestor host elements
        // that they're good to go and loaded (cuz this one is on its way out)
        T(e, t), 
        // since we're disconnecting, call all of the JSX ref's with null
        b(e._$vnodeMap$_.get(t), !0);
        {
          // call instance componentDidUnload
          // if we've created an instance for this
          const n = e._$instanceMap$_.get(t);
          n && n.componentDidUnload && 
          // call the user's componentDidUnload if there is one
          n.componentDidUnload();
        }
        // detatch any event listeners that may have been added
        // because we're not passing an exact event name it'll
        // remove all of this element's event, which is good
                e._$domApi$_._$$removeEventListener$_(t), e._$hasListenersMap$_.delete(t), 
        // clear any references to other elements
        // more than likely we've already deleted these references
        // but let's double check there pal
        [ e._$ancestorHostElementMap$_, e._$onReadyCallbacksMap$_, e._$hostSnapshotMap$_ ].forEach(e => e.delete(t));
      }
    })(e, this);
  }, n["s-init"] = function() {
    ((e, t, n, o, l, i, s) => {
      // all is good, this component has been told it's time to finish loading
      // it's possible that we've already decided to destroy this element
      // check if this element has any actively loading child elements
      if ((l = e._$instanceMap$_.get(t)) && !e._$isDisconnectedMap$_.has(t) && (!t["s-ld"] || !t["s-ld"].length)) {
        // cool, so at this point this element isn't already being destroyed
        // and it does not have any child elements that are still loading
        // all of this element's children have loaded (if any)
        e._$isCmpReady$_.set(t, !0), (s = e._$isCmpLoaded$_.has(t)) || (
        // remember that this component has loaded
        // isCmpLoaded map is useful to know if we should fire
        // the lifecycle componentDidLoad() or componentDidUpdate()
        e._$isCmpLoaded$_.set(t, !0), 
        // ensure we remove any child references cuz it doesn't matter at this point
        t["s-ld"] = void 0, 
        // add the css class that this element has officially hydrated
        e._$domApi$_._$$addClass$_(t, n));
        try {
          // fire off the ref if it exists
          b(e._$vnodeMap$_.get(t)), 
          // fire off the user's elm.componentOnReady() callbacks that were
          // put directly on the element (well before anything was ready)
          (i = e._$onReadyCallbacksMap$_.get(t)) && (i.forEach(e => e(t)), e._$onReadyCallbacksMap$_.delete(t)), 
          !s && l.componentDidLoad ? l.componentDidLoad() : s && l.componentDidUpdate && l.componentDidUpdate();
        } catch (n) {
          e._$onError$_(n, 4 /* DidLoadError */ , t);
        }
        // ( •_•)
        // ( •_•)>⌐■-■
        // (⌐■_■)
        // load events fire from bottom to top
        // the deepest elements load first then bubbles up
        T(e, t);
      }
    })(e, this, o);
  }, n.forceUpdate = function() {
    C(e, this, l);
  }, t._$membersMeta$_) {
    const o = Object.entries(t._$membersMeta$_);
    {
      let e = {};
      o.forEach(([t, {_$attribName$_: n}]) => {
        n && (e[n] = t);
      }), e = Object.assign({}, e), n.attributeChangedCallback = function(t, n, o) {
        // the browser has just informed us that an attribute
        // on the host element has changed
        (function attributeChangedCallback(e, t, n, o) {
          // look up to see if we have a property wired up to this attribute name
          const l = e[s(n)];
          l && (
          // there is not need to cast the value since, it's already casted when
          // the prop is setted
          t[l] = (null !== o || "boolean" != typeof t[l]) && o);
        })(e, this, t, o);
      };
    }
    // add getters/setters to the host element members
    // these would come from the @Prop and @Method decorators that
    // should create the public API to this component
        I(e, o, n, l);
  }
};

// esm build which uses es module imports and dynamic imports
((t, n, a, r, c, f, p) => {
  const d = a.performance, b = {
    html: {}
  }, h = a[t] = a[t] || {}, y = ((e, t, n) => {
    // using the $ prefix so that closure is
    // cool with property renaming each of these
    const l = new WeakMap(), i = {
      _$$doc$_: n,
      _$$supportsShadowDom$_: !!n.documentElement.attachShadow,
      _$$supportsEventOptions$_: !1,
      _$$nodeType$_: e => e.nodeType,
      _$$createElement$_: e => n.createElement(e),
      _$$createElementNS$_: (e, t) => n.createElementNS(e, t),
      _$$createTextNode$_: e => n.createTextNode(e),
      _$$createComment$_: e => n.createComment(e),
      _$$insertBefore$_: (e, t, n) => e.insertBefore(t, n),
      // https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
      // and it's polyfilled in es5 builds
      _$$remove$_: e => e.remove(),
      _$$appendChild$_: (e, t) => e.appendChild(t),
      _$$addClass$_: (e, t) => {
        e.classList.add(t);
      },
      _$$childNodes$_: e => e.childNodes,
      _$$parentNode$_: e => e.parentNode,
      _$$nextSibling$_: e => e.nextSibling,
      _$$previousSibling$_: e => e.previousSibling,
      _$$tagName$_: e => s(e.nodeName),
      _$$getTextContent$_: e => e.textContent,
      _$$setTextContent$_: (e, t) => e.textContent = t,
      _$$getAttribute$_: (e, t) => e.getAttribute(t),
      _$$setAttribute$_: (e, t, n) => e.setAttribute(t, n),
      _$$removeAttribute$_: (e, t) => e.removeAttribute(t),
      _$$hasAttribute$_: (e, t) => e.hasAttribute(t),
      _$$getMode$_: t => t.getAttribute("mode") || (e.Context || {}).mode,
      _$$elementRef$_: (e, o) => "child" === o ? e.firstElementChild : "parent" === o ? i._$$parentElement$_(e) : "body" === o ? n.body : "document" === o ? n : "window" === o ? t : e,
      _$$addEventListener$_: (t, n, s, a, r, c, f, p, u, d) => {
        // remember the original name before we possibly change it
        let m = t, b = s, h = l.get(t);
        d = n + a, h && h[d] && 
        // removed any existing listeners for this event for the assigner element
        // this element already has this listener, so let's unregister it now
        h[d](), "string" == typeof f ? 
        // attachTo is a string, and is probably something like
        // "parent", "window", or "document"
        // and the eventName would be like "mouseover" or "mousemove"
        m = i._$$elementRef$_(t, f) : "object" == typeof f ? 
        // we were passed in an actual element to attach to
        m = f : (
        // depending on the event name, we could actually be attaching
        // this element to something like the document or window
        u = n.split(":")).length > 1 && (
        // document:mousemove
        // parent:touchend
        // body:keyup.enter
        m = i._$$elementRef$_(t, u[0]), n = u[1]), m && ((
        // test to see if we're looking for an exact keycode
        u = n.split(".")).length > 1 && (
        // looks like this listener is also looking for a keycode
        // keyup.enter
        n = u[0], b = (e => {
          // wrap the user's event listener with our own check to test
          // if this keyboard event has the keycode they're looking for
          e.keyCode === o[u[1]] && s(e);
        })), 
        // create the actual event listener options to use
        // this browser may not support event options
        p = i._$$supportsEventOptions$_ ? {
          capture: !!r,
          passive: !!c
        } : !!r, 
        // ok, good to go, let's add the actual listener to the dom element
        e.ael(m, n, b, p), h || 
        // we don't already have a collection, let's create it
        l.set(t, h = {}), 
        // add the unregister listener to this element's collection
        h[d] = (() => {
          // looks like it's time to say goodbye
          m && e.rel(m, n, b, p), h[d] = null;
        }));
      },
      _$$removeEventListener$_: (e, t, n, o) => {
        // get the unregister listener functions for this element
        (o = l.get(e)) && (
        // this element has unregister listeners
        t ? 
        // passed in one specific event name to remove
        o[t + n] && o[t + n]() : 
        // remove all event listeners
        Object.keys(o).forEach(e => {
          o[e] && o[e]();
        }));
      },
      _$$dispatchEvent$_: (e, n, o, l) => (
      // create and return the custom event, allows for cancel checks
      l = new t.CustomEvent(n, o), e && e.dispatchEvent(l), l),
      _$$parentElement$_: (e, t) => 
      // if the parent node is a document fragment (shadow root)
      // then use the "host" property on it
      // otherwise use the parent node
      (t = i._$$parentNode$_(e)) && 11 /* DocumentFragment */ === i._$$nodeType$_(t) ? t.host : t,
      _$$setAttributeNS$_: (e, t, n, o) => e.setAttributeNS(t, n, o),
      _$$attachShadow$_: (e, t) => e.attachShadow(t)
    };
    e.ael || (e.ael = ((e, t, n, o) => e.addEventListener(t, n, o)), e.rel = ((e, t, n, o) => e.removeEventListener(t, n, o)));
    // test if this browser supports event options or not
    try {
      t.addEventListener("e", null, Object.defineProperty({}, "passive", {
        get: () => i._$$supportsEventOptions$_ = !0
      }));
    } catch (e) {}
    return i;
  })(h, a, r), g = y._$$doc$_.documentElement, w = a["s-defined"] = a["s-defined"] || {}, M = (e, t) => {
    a.customElements.get(e._$tagNameMeta$_) || (
    // define the custom element
    // initialize the members on the host element prototype
    // keep a ref to the metadata with the tag as the key
    P(k, b[e._$tagNameMeta$_] = e, t.prototype, f, d), 
    // add which attributes should be observed
    // at this point the membersMeta only includes attributes which should
    // be observed, it does not include all props yet, so it's safe to
    // loop through all of the props (attrs) and observed them
    // set the array of all the attributes to keep an eye on
    // https://www.youtube.com/watch?v=RBs21CFBALI
    t.observedAttributes = Object.values(e._$membersMeta$_).map(e => e._$attribName$_).filter(e => !!e), 
    a.customElements.define(e._$tagNameMeta$_, t));
  }, k = {
    _$domApi$_: y,
    _$defineComponent$_: M,
    _$getComponentMeta$_: e => b[y._$$tagName$_(e)],
    _$getContextItem$_: e => n[e],
    isClient: !0,
    _$isDefinedComponent$_: e => !(!w[y._$$tagName$_(e)] && !k._$getComponentMeta$_(e)),
    _$onError$_: (e, t, n) => console.error(e, t, n && n.tagName),
    queue: n.queue = v(h, a),
    _$requestBundle$_: (t, n) => {
      {
        // self loading module using built-in browser's import()
        // this is when not using a 3rd party bundler
        // and components are able to lazy load themselves
        // through standardized browser APIs
        const o = t._$bundleIds$_, l = !y._$$supportsShadowDom$_;
        let i = c + o + (l ? ".sc" : "") + ".entry.js";
        // dynamic es module import() => woot!
        import(i).then(o => {
          try {
            // get the component constructor from the module
            // initialize this component constructor's styles
            // it is possible for the same component to have difficult styles applied in the same app
            t._$componentConstructor$_ = o[(e => s(e).split("-").map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(""))(t._$tagNameMeta$_)], 
            function initStyleTemplate(t, n, o, l, i) {
              if (l) {
                // we got a style mode for this component, let's create an id for this style
                const o = n._$tagNameMeta$_ + (i || e);
                if (!n[o]) {
                  // use <template> elements to clone styles
                  // create the template element which will hold the styles
                  // adding it to the dom via <template> so that we can
                  // clone this for each potential shadow root that will need these styles
                  // otherwise it'll be cloned and added to document.body.head
                  // but that's for the renderer to figure out later
                  const e = t._$$createElement$_("template");
                  // keep a reference to this template element within the
                  // Constructor using the style mode id as the key
                                    n[o] = e, 
                  // prod mode, no style id data attributes
                  e.innerHTML = `<style>${l}</style>`, 
                  // add our new template element to the head
                  // so it can be cloned later
                  t._$$appendChild$_(t._$$doc$_.head, e);
                }
              }
            }(y, t, t._$encapsulationMeta$_, t._$componentConstructor$_.style, t._$componentConstructor$_.styleMode), 
            // bundle all loaded up, let's continue
            C(k, n, d);
          } catch (e) {
            // oh man, something's up
            console.error(e), 
            // provide a bogus component constructor
            // so the rest of the app acts as normal
            t._$componentConstructor$_ = class {};
          }
        }, e => console.error(e, i));
      }
    },
    _$activeRender$_: !1,
    _$isAppLoaded$_: !1,
    _$tmpDisconnected$_: !1,
    _$attachStyles$_: l,
    _$ancestorHostElementMap$_: new WeakMap(),
    _$componentAppliedStyles$_: new WeakMap(),
    _$hasConnectedMap$_: new WeakMap(),
    _$hasListenersMap$_: new WeakMap(),
    _$isCmpLoaded$_: new WeakMap(),
    _$isCmpReady$_: new WeakMap(),
    _$hostElementMap$_: new WeakMap(),
    _$hostSnapshotMap$_: new WeakMap(),
    _$instanceMap$_: new WeakMap(),
    _$isDisconnectedMap$_: new WeakMap(),
    _$isQueuedForUpdate$_: new WeakMap(),
    _$onReadyCallbacksMap$_: new WeakMap(),
    _$queuedEvents$_: new WeakMap(),
    _$vnodeMap$_: new WeakMap(),
    _$valuesMap$_: new WeakMap(),
    _$processingCmp$_: new Set(),
    _$onAppReadyCallbacks$_: []
  };
  // set App Context
  return n.isServer = n.isPrerender = !(n.isClient = !0), n.window = a, n.location = a.location, 
  n.document = r, n.resourcesUrl = n.publicPath = c, k._$emitEvent$_ = n.emit = ((e, t, o) => y._$$dispatchEvent$_(e, n.eventNameFn ? n.eventNameFn(t) : t, o)), 
  // add the h() fn to the app's global namespace
  h.h = h$1, h.Context = n, 
  // create a method that returns a promise
  // which gets resolved when the app's queue is empty
  // and app is idle, works for both initial load and updates
  h.onReady = (() => new Promise(e => k.queue.write(() => k._$processingCmp$_.size ? k._$onAppReadyCallbacks$_.push(e) : e()))), 
  // create the renderer that will be used
  k.render = ((e, t) => {
    // createRenderer() is only created once per app
    // the patch() function which createRenderer() returned is the function
    // which gets called numerous times by each component
    // internal variables to be reused per patch() call
    let n, o, l, s, a, r, c;
    const f = (l, d, b, h, v, y, g, w, $) => {
      if (w = d.vchildren[b], n || (
      // remember for later we need to check to relocate nodes
      s = !0, "slot" === w.vtag && (o && 
      // scoped css needs to add its scoped id to the parent element
      t._$$addClass$_(h, o + "-s"), w.vchildren ? 
      // slot element has fallback content
      // still create an element that "mocks" the slot element
      w._$isSlotFallback$_ = !0 : 
      // slot element does not have fallback content
      // create an html comment we'll use to always reference
      // where actual slot content should sit next to
      w._$isSlotReference$_ = !0)), i(w.vtext)) 
      // create text node
      w._$elm$_ = t._$$createTextNode$_(w.vtext); else if (w._$isSlotReference$_) 
      // create a slot reference html text node
      w._$elm$_ = t._$$createTextNode$_(""); else {
        if (
        // create element
        y = w._$elm$_ = m || "svg" === w.vtag ? t._$$createElementNS$_("http://www.w3.org/2000/svg", w.vtag) : t._$$createElement$_(w._$isSlotFallback$_ ? "slot-fb" : w.vtag), 
        e._$isDefinedComponent$_(y) && e._$isCmpReady$_.delete(c), m = "svg" === w.vtag || "foreignObject" !== w.vtag && m, 
        // add css classes, attrs, props, listeners, etc.
        u(e, null, w, m), i(o) && y["s-si"] !== o && 
        // if there is a scopeId and this is the initial render
        // then let's add the scopeId as an attribute
        t._$$addClass$_(y, y["s-si"] = o), w.vchildren) for (v = 0; v < w.vchildren.length; ++v) 
        // create the node
        // return node could have been null
        (g = f(l, w, v, y)) && 
        // append our new node
        t._$$appendChild$_(y, g);
        "svg" === w.vtag && (
        // Only reset the SVG context when we're exiting SVG element
        m = !1);
      }
      return w._$elm$_["s-hn"] = r, (w._$isSlotFallback$_ || w._$isSlotReference$_) && (
      // remember the content reference comment
      w._$elm$_["s-sr"] = !0, 
      // remember the content reference comment
      w._$elm$_["s-cr"] = a, 
      // remember the slot name, or empty string for default slot
      w._$elm$_["s-sn"] = w.vname || "", (
      // check if we've got an old vnode for this slot
      $ = l && l.vchildren && l.vchildren[b]) && $.vtag === w.vtag && l._$elm$_ && 
      // we've got an old slot vnode and the wrapper is being replaced
      // so let's move the old slot content back to it's original location
      p(l._$elm$_)), w._$elm$_;
    }, p = (n, o, l, i) => {
      e._$tmpDisconnected$_ = !0;
      const a = t._$$childNodes$_(n);
      for (l = a.length - 1; l >= 0; l--) (i = a[l])["s-hn"] !== r && i["s-ol"] && (
      // this child node in the old element is from another component
      // remove this node from the old slot's parent
      t._$$remove$_(i), 
      // and relocate it back to it's original location
      t._$$insertBefore$_(y(i), i, v(i)), 
      // remove the old original location comment entirely
      // later on the patch function will know what to do
      // and move this to the correct spot in need be
      t._$$remove$_(i["s-ol"]), i["s-ol"] = null, s = !0), o && p(i, o);
      e._$tmpDisconnected$_ = !1;
    }, d = (e, n, o, l, s, a, c, p) => {
      const u = e["s-cr"];
      for ((c = u && t._$$parentNode$_(u) || e).shadowRoot && t._$$tagName$_(c) === r && (c = c.shadowRoot); s <= a; ++s) l[s] && (p = i(l[s].vtext) ? t._$$createTextNode$_(l[s].vtext) : f(null, o, s, e)) && (l[s]._$elm$_ = p, 
      t._$$insertBefore$_(c, p, v(n)));
    }, b = (e, n, o, s) => {
      for (;n <= o; ++n) i(e[n]) && (s = e[n]._$elm$_, 
      // we're removing this element
      // so it's possible we need to show slot fallback content now
      l = !0, s["s-ol"] ? 
      // remove the original location comment
      t._$$remove$_(s["s-ol"]) : 
      // it's possible that child nodes of the node
      // that's being removed are slot nodes
      p(s, !0), 
      // remove the vnode's element from the dom
      t._$$remove$_(s));
    }, h = (e, t) => 
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    e.vtag === t.vtag && e.vkey === t.vkey && ("slot" !== e.vtag || e.vname === t.vname), v = e => e && e["s-ol"] ? e["s-ol"] : e, y = e => t._$$parentNode$_(e["s-ol"] ? e["s-ol"] : e), g = (n, o, l) => {
      const s = o._$elm$_ = n._$elm$_, a = n.vchildren, r = o.vchildren;
      // test if we're rendering an svg element, or still rendering nodes inside of one
      // only add this to the when the compiler sees we're using an svg somewhere
      m = o._$elm$_ && i(t._$$parentElement$_(o._$elm$_)) && void 0 !== o._$elm$_.ownerSVGElement, 
      m = "svg" === o.vtag || "foreignObject" !== o.vtag && m, i(o.vtext) ? (l = s["s-cr"]) ? 
      // this element has slotted content
      t._$$setTextContent$_(t._$$parentNode$_(l), o.vtext) : n.vtext !== o.vtext && 
      // update the text content for the text only vnode
      // and also only if the text is different than before
      t._$$setTextContent$_(s, o.vtext) : (
      // element node
      "slot" !== o.vtag && 
      // either this is the first render of an element OR it's an update
      // AND we already know it's possible it could have changed
      // this updates the element's css classes, attrs, props, listeners, etc.
      u(e, n, o, m), i(a) && i(r) ? 
      // looks like there's child vnodes for both the old and new vnodes
      ((e, n, o, l, s, a, r, c) => {
        let u = 0, m = 0, w = n.length - 1, $ = n[0], M = n[w], k = l.length - 1, C = l[0], S = l[k];
        for (;u <= w && m <= k; ) if (null == $) 
        // Vnode might have been moved left
        $ = n[++u]; else if (null == M) M = n[--w]; else if (null == C) C = l[++m]; else if (null == S) S = l[--k]; else if (h($, C)) g($, C), 
        $ = n[++u], C = l[++m]; else if (h(M, S)) g(M, S), M = n[--w], S = l[--k]; else if (h($, S)) 
        // Vnode moved right
        "slot" !== $.vtag && "slot" !== S.vtag || p(t._$$parentNode$_($._$elm$_)), g($, S), 
        t._$$insertBefore$_(e, $._$elm$_, t._$$nextSibling$_(M._$elm$_)), $ = n[++u], S = l[--k]; else if (h(M, C)) 
        // Vnode moved left
        "slot" !== $.vtag && "slot" !== S.vtag || p(t._$$parentNode$_(M._$elm$_)), g(M, C), 
        t._$$insertBefore$_(e, M._$elm$_, $._$elm$_), M = n[--w], C = l[++m]; else {
          for (
          // createKeyToOldIdx
          s = null, a = u; a <= w; ++a) if (n[a] && i(n[a].vkey) && n[a].vkey === C.vkey) {
            s = a;
            break;
          }
          i(s) ? ((c = n[s]).vtag !== C.vtag ? r = f(n && n[m], o, s, e) : (g(c, C), n[s] = void 0, 
          r = c._$elm$_), C = l[++m]) : (
          // new element
          r = f(n && n[m], o, m, e), C = l[++m]), r && t._$$insertBefore$_(y($._$elm$_), r, v($._$elm$_));
        }
        u > w ? d(e, null == l[k + 1] ? null : l[k + 1]._$elm$_, o, l, m, k) : m > k && b(n, u, w);
      })(s, a, o, r) : i(r) ? (
      // no old child vnodes, but there are new child vnodes to add
      i(n.vtext) && 
      // the old vnode was text, so be sure to clear it out
      t._$$setTextContent$_(s, ""), 
      // add the new vnode children
      d(s, null, o, r, 0, r.length - 1)) : i(a) && 
      // no new child vnodes, but there are old child vnodes to remove
      b(a, 0, a.length - 1)), 
      // reset svgMode when svg node is fully patched
      m && "svg" === o.vtag && (m = !1);
    }, w = (e, n, o, l, i, s, a, r) => {
      for (l = 0, i = (o = t._$$childNodes$_(e)).length; l < i; l++) if (n = o[l], 1 /* ElementNode */ === t._$$nodeType$_(n)) {
        if (n["s-sr"]) for (
        // this is a slot fallback node
        // get the slot name for this slot reference node
        a = n["s-sn"], 
        // by default always show a fallback slot node
        // then hide it if there are other slots in the light dom
        n.hidden = !1, s = 0; s < i; s++) if (o[s]["s-hn"] !== n["s-hn"]) if (
        // this sibling node is from a different component
        r = t._$$nodeType$_(o[s]), "" !== a) {
          // this is a named fallback slot node
          if (1 /* ElementNode */ === r && a === t._$$getAttribute$_(o[s], "slot")) {
            n.hidden = !0;
            break;
          }
        } else 
        // this is a default fallback slot node
        // any element or text node (with content)
        // should hide the default fallback slot node
        if (1 /* ElementNode */ === r || 3 /* TextNode */ === r && "" !== t._$$getTextContent$_(o[s]).trim()) {
          n.hidden = !0;
          break;
        }
        // keep drilling down
                w(n);
      }
    }, $ = [], M = (e, n, o, i, s, a, r, c, f, p) => {
      for (s = 0, a = (n = t._$$childNodes$_(e)).length; s < a; s++) {
        if ((o = n[s])["s-sr"] && (i = o["s-cr"])) for (
        // first got the content reference comment node
        // then we got it's parent, which is where all the host content is in now
        c = t._$$childNodes$_(t._$$parentNode$_(i)), f = o["s-sn"], r = c.length - 1; r >= 0; r--) (i = c[r])["s-cn"] || i["s-nr"] || i["s-hn"] === o["s-hn"] || ((3 /* TextNode */ === (
        // let's do some relocating to its new home
        // but never relocate a content reference node
        // that is suppose to always represent the original content location
        p = t._$$nodeType$_(i)) || 8 /* CommentNode */ === p) && "" === f || 1 /* ElementNode */ === p && null === t._$$getAttribute$_(i, "slot") && "" === f || 1 /* ElementNode */ === p && t._$$getAttribute$_(i, "slot") === f) && (
        // it's possible we've already decided to relocate this node
        $.some(e => e._$nodeToRelocate$_ === i) || (
        // made some changes to slots
        // let's make sure we also double check
        // fallbacks are correctly hidden or shown
        l = !0, i["s-sn"] = f, 
        // add to our list of nodes to relocate
        $.push({
          _$slotRefNode$_: o,
          _$nodeToRelocate$_: i
        })));
        1 /* ElementNode */ === t._$$nodeType$_(o) && M(o);
      }
    };
    return (i, f, p, u, d, m, b, h, v, y, k, C) => {
      if (
      // patchVNode() is synchronous
      // so it is safe to set these variables and internally
      // the same patch() call will reference the same data
      c = i, r = t._$$tagName$_(c), a = c["s-cr"], n = u, 
      // get the scopeId
      o = c["s-sc"], 
      // always reset
      s = l = !1, 
      // synchronous patch
      g(f, p), s) {
        for (M(p._$elm$_), b = 0; b < $.length; b++) (h = $[b])._$nodeToRelocate$_["s-ol"] || (
        // add a reference node marking this node's original location
        // keep a reference to this node for later lookups
        (v = t._$$createTextNode$_(""))["s-nr"] = h._$nodeToRelocate$_, t._$$insertBefore$_(t._$$parentNode$_(h._$nodeToRelocate$_), h._$nodeToRelocate$_["s-ol"] = v, h._$nodeToRelocate$_));
        // while we're moving nodes around existing nodes, temporarily disable
        // the disconnectCallback from working
                for (e._$tmpDisconnected$_ = !0, b = 0; b < $.length; b++) {
          for (h = $[b], 
          // by default we're just going to insert it directly
          // after the slot reference node
          k = t._$$parentNode$_(h._$slotRefNode$_), C = t._$$nextSibling$_(h._$slotRefNode$_), 
          v = h._$nodeToRelocate$_["s-ol"]; v = t._$$previousSibling$_(v); ) if ((y = v["s-nr"]) && y && y["s-sn"] === h._$nodeToRelocate$_["s-sn"] && k === t._$$parentNode$_(y) && (y = t._$$nextSibling$_(y)) && y && !y["s-nr"]) {
            C = y;
            break;
          }
          (!C && k !== t._$$parentNode$_(h._$nodeToRelocate$_) || t._$$nextSibling$_(h._$nodeToRelocate$_) !== C) && h._$nodeToRelocate$_ !== C && (
          // remove the node from the dom
          t._$$remove$_(h._$nodeToRelocate$_), 
          // add it back to the dom but in its new home
          t._$$insertBefore$_(k, h._$nodeToRelocate$_, C));
        }
        // done moving nodes around
        // allow the disconnect callback to work again
                e._$tmpDisconnected$_ = !1;
      }
      // return our new vnode
      return l && w(p._$elm$_), 
      // always reset
      $.length = 0, p;
    };
  })(k, y), 
  // setup the root element which is the mighty <html> tag
  // the <html> has the final say of when the app has loaded
  g["s-ld"] = [], g["s-rn"] = !0, 
  // this will fire when all components have finished loaded
  g["s-init"] = (() => {
    k._$isCmpReady$_.set(g, h.loaded = k._$isAppLoaded$_ = !0), y._$$dispatchEvent$_(a, "appload", {
      detail: {
        namespace: t
      }
    });
  }), p.map($).forEach(e => M(e, class extends HTMLElement {})), k._$hasConnectedComponent$_ || 
  // we just defined call the custom elements but no
  // connectedCallbacks happened, so no components in the dom :(
  g["s-init"](), 
  // create the componentOnReady fn
  ((e, t, n, o, l, i) => {
    if (
    // add componentOnReady() to the App object
    // this also is used to know that the App's core is ready
    t.componentOnReady = ((t, n) => {
      if (!t.nodeName.includes("-")) return n(null), !1;
      const o = e._$getComponentMeta$_(t);
      if (o) if (e._$isCmpReady$_.has(t)) 
      // element has already loaded, pass the resolve the element component
      // so we know that the resolve knows it this element is an app component
      n(t); else {
        // element hasn't loaded yet or it has an update in progress
        // add this resolve specifically to this elements on ready queue
        const o = e._$onReadyCallbacksMap$_.get(t) || [];
        o.push(n), e._$onReadyCallbacksMap$_.set(t, o);
      }
      // return a boolean if this app recognized this element or not
            return !!o;
    }), l) {
      // we've got some componentOnReadys in the queue before the app was ready
      for (i = l.length - 1; i >= 0; i--) 
      // go through each element and see if this app recongizes it
      t.componentOnReady(l[i][0], l[i][1]) && 
      // turns out this element belongs to this app
      // remove the resolve from the queue so in the end
      // all that's left in the queue are elements not apart of any apps
      l.splice(i, 1);
      for (i = 0; i < o.length; i++) if (!n[o[i]].componentOnReady) 
      // there is at least 1 apps that isn't ready yet
      // so let's stop here cuz there's still app cores loading
      return;
      // if we got to this point then that means all of the apps are ready
      // and they would have removed any of their elements from queuedComponentOnReadys
      // so let's do the cleanup of the  remaining queuedComponentOnReadys
            for (i = 0; i < l.length; i++) 
      // resolve any queued componentsOnReadys that are left over
      // since these elements were not apart of any apps
      // call the resolve fn, but pass null so it's know this wasn't a known app component
      l[i][1](null);
      l.length = 0;
    }
  })(k, h, a, a["s-apps"], a["s-cr"]), 
  // notify that the app has initialized and the core script is ready
  // but note that the components have not fully loaded yet
  h.initialized = !0, k;
})(n, x, w, d, r, h, c);
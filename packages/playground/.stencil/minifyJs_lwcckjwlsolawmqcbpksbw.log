

const t = "http://localhost:9000", e = 3e4;

function timeout(t = e) {
  const r = setTimeout(() => {
    throw new Error("Request timed out");
  }, t);
  return {
    cancel() {
      clearTimeout(r);
    }
  };
}

async function request(e, r, s, a, c = "Signature") {
  return await fetch(`${t}/api/${r}`, Object.assign({
    method: e
  }, [ "POST", "PUT" ].includes(e) ? {
    body: JSON.stringify({
      data: s
    })
  } : {}, {
    headers: Object.assign({
      "Content-Type": "application/json; charset=utf-8"
    }, a ? {
      Authorization: `${c} ${a}`
    } : {})
  }));
}

async function post(t, e, r, s = "Signature") {
  const a = timeout(), c = await request("POST", t, e, r, s);
  a.cancel();
  const o = await c.json();
  if (o.errors) throw o.errors[0];
  return o;
}

async function get(t, e) {
  const r = timeout(), s = await request("GET", t, {}, e, "Bearer");
  r.cancel();
  const a = await s.json();
  if (a.errors) throw a.errors[0];
  return a;
}

function fromAPIResource(t) {
  return Object.assign({
    id: t.id
  }, t.attributes);
}

function toAPIResource(t) {
  return Object.assign({}, t.id ? {
    id: t.id
  } : {}, {
    attributes: Object.assign({}, Object.keys(t).map(e => ({
      [e]: t[e]
    })).reduce((t, e) => Object.assign({}, t, e), {}))
  });
}

class r {
  static async getHeartbeat() {
    try {
      return (await get("heartbeats")).data[0].attributes;
    } catch (t) {
      return {
        schemaVersion: "",
        maintenanceMode: !0
      };
    }
  }
  static async createAccount(t, e) {
    try {
      const r = toAPIResource(t), s = (await post("users", r, e)).data, a = await post("multisig-deploys", {
        type: "multisigDeploy",
        attributes: {
          ethAddress: t.ethAddress
        }
      });
      return s.attributes.transactionHash = a.data.id, fromAPIResource(s);
    } catch (t) {
      return Promise.reject(t);
    }
  }
  static async updateAccount(t) {
    try {
      const e = toAPIResource(t);
      return fromAPIResource((await async function(t, e, r) {
        const s = timeout(), a = await request("PUT", `users/${e.id}`, e, r);
        s.cancel();
        const c = await a.json();
        if (c.errors) throw c.errors[0];
        return c;
      }(0, e, window.localStorage.getItem("playground:user:token"))).data);
    } catch (t) {
      return Promise.reject(t);
    }
  }
  static async deleteAccount(e) {
    try {
      const r = toAPIResource(e);
      await async function(e, r, s, a = "Signature") {
        const c = timeout(), o = await fetch(`${t}/api/users/${r.attributes.id}`, {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json; charset=utf-8",
            Authorization: `${a} ${s}`
          }
        });
        c.cancel();
        const n = await o.json();
        if (n.errors) throw n.errors[0];
        return n;
      }(0, r, window.localStorage.getItem("playground:user:token"));
    } catch (t) {
      return Promise.reject(t);
    }
  }
  static async login(t, e) {
    try {
      return fromAPIResource((await post("session-requests", {
        type: "session",
        id: "",
        attributes: {
          ethAddress: t.ethAddress
        }
      }, e)).data);
    } catch (t) {
      return Promise.reject(t);
    }
  }
  static async getUser(t) {
    if (!t) throw new Error("getUser(): token is required");
    try {
      return fromAPIResource((await get("users/me", t)).data[0]);
    } catch (t) {
      return Promise.reject(t);
    }
  }
  static async getUserByNodeAddress(t) {
    try {
      return fromAPIResource((await get(`users?filter[node_address]=${t}`)).data[0]);
    } catch (t) {
      return Promise.reject(t);
    }
  }
  static async getApps() {
    try {
      return (await get("apps")).data.map(t => fromAPIResource(t));
    } catch (t) {
      return Promise.reject(t);
    }
  }
  static async matchmake(t, e) {
    try {
      return await post("matchmaking-requests", {
        type: "matchmakingRequest",
        attributes: e ? {
          matchmakeWith: e
        } : {}
      }, t, "Bearer");
    } catch (t) {
      return Promise.reject(t);
    }
  }
}

export { r as a };
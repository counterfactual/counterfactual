const e = window.App.h;

import "./chunk-deed3e85.js";

import { a as t } from "./chunk-dfef6d51.js";

import { a as s } from "./chunk-868ccbc3.js";

import { a as r } from "./chunk-515d15f9.js";

import { a as n } from "./chunk-a343ce23.js";

import { a } from "./chunk-adf5a5b1.js";

class i {
  constructor() {
    this.onDeposit = (() => {}), this.onReject = (() => {});
  }
  render() {
    return e("widget-dialog", {
      visible: !0,
      dialogTitle: "Insufficient funds",
      content: e("label", null, "You need at least", " ", window.ethers.utils.formatEther(this.message.minimumEthBalance), " ", "ETH to ETH in your Playground account to install this game."),
      primaryButtonText: "Deposit",
      onPrimaryButtonClicked: () => this.onDeposit(),
      secondaryButtonText: "Reject",
      onSecondaryButtonClicked: () => this.onReject()
    });
  }
  static get is() {
    return "dialog-insufficient-funds";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      message: {
        type: "Any",
        attr: "message"
      },
      onDeposit: {
        type: "Any",
        attr: "on-deposit"
      },
      onReject: {
        type: "Any",
        attr: "on-reject"
      }
    };
  }
}

const o = "42";

class l {
  constructor() {
    this.el = {}, this.onAccept = (() => {}), this.onReject = (() => {}), this.apps = [], 
    this.user = {};
  }
  async componentWillLoad() {
    this.message.data && (this.user = await a.getUserByNodeAddress(this.message.data.proposedByIdentifier));
  }
  render() {
    const t = this.apps.find(e => e.id[o] === this.message.data.params.appDefinition);
    if (!t) throw Error("You've received an installation proposal from a different Ethereum network");
    return e("widget-dialog", {
      visible: !0,
      dialogTitle: "You've been invited to play!",
      content: e("label", null, "You'll need to deposit", e("br", null), e("strong", null, window.ethers.utils.formatEther(this.message.data.params.initiatorDeposit), " ", "ETH"), " ", "to play ", e("strong", null, t.name), " with", " ", e("strong", null, this.user.username), "."),
      primaryButtonText: "Accept",
      onPrimaryButtonClicked: () => this.onAccept(this.message),
      secondaryButtonText: "Reject",
      onSecondaryButtonClicked: () => this.onReject()
    });
  }
  static get is() {
    return "dialog-propose-install";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      apps: {
        type: "Any",
        attr: "apps"
      },
      el: {
        elementRef: !0
      },
      message: {
        type: "Any",
        attr: "message"
      },
      onAccept: {
        type: "Any",
        attr: "on-accept"
      },
      onReject: {
        type: "Any",
        attr: "on-reject"
      },
      user: {
        state: !0
      }
    };
  }
}

s.injectProps(l, [ "apps" ]);

class c {
  constructor() {
    this.onOKClicked = (() => {}), this.onReject = (() => {}), this.username = "";
  }
  componentWillLoad() {
    const e = JSON.parse(window.localStorage.getItem("playground:lastMatchmake") || '{"attributes":{"username":"Your opponent"}}');
    this.username = e.data.attributes.username;
  }
  render() {
    return e("widget-dialog", {
      visible: !0,
      dialogTitle: "Sorry :(",
      content: e("label", null, e("strong", null, this.username), " has declined your invitation to play."),
      primaryButtonText: "OK",
      onPrimaryButtonClicked: () => this.onOKClicked()
    });
  }
  static get is() {
    return "dialog-reject-install";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      message: {
        type: "Any",
        attr: "message"
      },
      onOKClicked: {
        type: "Any",
        attr: "on-o-k-clicked"
      },
      onReject: {
        type: "Any",
        attr: "on-reject"
      },
      username: {
        state: !0
      }
    };
  }
}

class d {
  constructor() {
    this.closeDrawer = {}, this.opened = !1;
  }
  menuClicked(e) {
    e.preventDefault(), this.closeDrawer.emit();
  }
  render() {
    return e("div", {
      class: this.opened ? "drawer-container opened" : "drawer-container"
    }, e("a", {
      onClick: e => this.menuClicked(e),
      class: "drawer-screen"
    }), e("menu", {
      class: "drawer"
    }, e("header-content", null)));
  }
  static get is() {
    return "header-drawer";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      opened: {
        type: Boolean,
        attr: "opened"
      }
    };
  }
  static get events() {
    return [ {
      name: "closeDrawer",
      method: "closeDrawer",
      bubbles: !0,
      cancelable: !0,
      composed: !0
    } ];
  }
  static get style() {
    return "/**style-placeholder:header-drawer:**/";
  }
}

class p {
  constructor() {
    this.drawerOpened = !1;
  }
  closeDrawerHandler(e) {
    this.drawerOpened = !1;
  }
  openDrawerHandler(e) {
    this.drawerOpened = !0;
  }
  render() {
    return [ e("header-drawer", {
      opened: this.drawerOpened,
      onCloseDrawer: e => this.closeDrawerHandler(e)
    }), e("header", {
      class: "header"
    }, e("div", {
      class: "hide-on-desktop"
    }, e("div", {
      class: "mobile-content"
    }, e("a", {
      class: "drawer-toggle",
      onClick: e => this.openDrawerHandler(e)
    }, e("img", {
      src: "/assets/icon/menu-btn.svg",
      alt: "Menu"
    })), e("div", {
      class: "logo-container"
    }, e("stencil-route-link", {
      url: "/"
    }, e("img", {
      src: "/assets/icon/logo.svg",
      alt: "Counterfactual",
      class: "logo"
    }))), e("div", {
      class: "account-container"
    }, e("header-balance", null)))), e("div", {
      class: "hide-on-mobile desktop-wrapper"
    }, e("header-content", null))) ];
  }
  static get is() {
    return "layout-header";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      drawerOpened: {
        state: !0
      }
    };
  }
  static get style() {
    return "/**style-placeholder:layout-header:**/";
  }
}

const h = "42";

class u {
  constructor() {
    this.el = {}, this.apps = [], this.web3Detected = !1, this.history = {}, this.provider = {}, 
    this.ethMultisigBalance = window.ethers.constants.Zero, this.nodeMessageResolver = {
      proposeInstallVirtualEvent: this.onProposeInstallVirtual.bind(this),
      rejectInstallEvent: this.onRejectInstall.bind(this),
      rejectInstallVirtualEvent: this.onRejectInstall.bind(this)
    };
  }
  get cfProvider() {
    return r.getCfProvider();
  }
  async componentWillLoad() {
    this.web3Detected && this.bindNodeEvents();
  }
  bindNodeEvents() {
    Object.keys(this.nodeMessageResolver).forEach(e => {
      this.cfProvider.off(e), this.cfProvider.on(e, this.nodeMessageResolver[e].bind(this));
    });
  }
  onProposeInstallVirtual(e) {
    this.currentMessage = e, this.showModal();
  }
  onRejectInstall(e) {
    this.currentMessage = e, this.showModal();
  }
  async acceptProposeInstall(e) {
    try {
      const t = this.ethMultisigBalance, s = window.ethers.utils.bigNumberify(e.data.params.initiatorDeposit);
      if (t.lt(s)) return this.currentModalType = "error", this.currentErrorType = "INSUFFICIENT_FUNDS", 
      void (this.currentMessage = {
        minimumEthBalance: s
      });
      const {appInstanceId: r, intermediaries: n} = this.currentMessage.data, [a] = n, i = await this.cfProvider.installVirtual(r, a), o = this.apps.find(e => e.id[h] === i.appInstance.appDefinition);
      if (!o) throw Error("You've received an installation proposal from a different Ethereum network");
      window.localStorage.setItem("playground:installingDapp", JSON.stringify({
        installedApp: i,
        name: o.name,
        dappContainerUrl: `/dapp/${o.slug}`,
        dappUrl: o.url
      })), this.history.push(`/dapp/${o.slug}`), this.hideModal();
    } catch (e) {
      this.currentModalType = "error", this.currentErrorType = e.message, console.error(e);
    }
  }
  async rejectProposeInstall() {
    await this.cfProvider.rejectInstall(this.currentMessage.data.appInstanceId), this.hideModal();
  }
  showModal() {
    this.currentModalType = this.currentMessage.type;
  }
  hideModal() {
    this.currentModalType = "none";
  }
  render() {
    let t = {};
    return "proposeInstallVirtualEvent" === this.currentModalType && (t = e("dialog-propose-install", {
      message: this.currentMessage,
      onAccept: this.acceptProposeInstall.bind(this),
      onReject: this.rejectProposeInstall.bind(this)
    })), "rejectInstallVirtualEvent" !== this.currentModalType && "rejectInstallEvent" !== this.currentModalType || (t = e("dialog-reject-install", {
      message: this.currentMessage,
      onOKClicked: this.hideModal.bind(this)
    })), "error" === this.currentModalType && (t = "INSUFFICIENT_FUNDS" === this.currentErrorType ? e("dialog-insufficient-funds", {
      message: this.currentMessage,
      onDeposit: this.hideModal.bind(this),
      onReject: this.rejectProposeInstall.bind(this)
    }) : e("widget-dialog", {
      dialogTitle: "Something went wrong",
      content: `${this.currentErrorType}. See the console for more info.`,
      primaryButtonText: "OK",
      onPrimaryButtonClicked: () => this.hideModal()
    })), [ e("slot", null), t ];
  }
  static get is() {
    return "node-listener";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      apps: {
        type: "Any",
        attr: "apps"
      },
      currentErrorType: {
        state: !0
      },
      currentMessage: {
        state: !0
      },
      currentModalType: {
        state: !0
      },
      el: {
        elementRef: !0
      },
      ethMultisigBalance: {
        type: "Any",
        attr: "eth-multisig-balance"
      },
      history: {
        type: "Any",
        attr: "history"
      },
      provider: {
        type: "Any",
        attr: "provider"
      },
      web3Detected: {
        type: Boolean,
        attr: "web-3-detected"
      }
    };
  }
}

s.injectProps(u, [ "apps" ]), t.injectProps(u, [ "ethMultisigBalance" ]), n.injectProps(u, [ "web3Detected", "provider" ]);

export { i as DialogInsufficientFunds, l as DialogProposeInstall, c as DialogRejectInstall, d as HeaderDrawer, p as LayoutHeader, u as NodeListener };
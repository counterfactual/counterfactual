import * as tslib_1 from "tslib";
import { h } from '../app.core.js';
import './chunk-deed3e85.js';
import { a as GameState, b as HighRollerStage, c as HighRollerActionType, e as CounterfactualTunnel } from './chunk-a0cc8100.js';
import { a as HighRollerUITunnel } from './chunk-91bb08fc.js';
import { a as matchPath, b as matchesAreEqual, c as ActiveRouter, d as storageAvailable, e as canUseDOM, f as supportsHistory, g as supportsPopStateOnHashChange, h as getConfirmation, i as stripTrailingSlash, j as addLeadingSlash, k as hasBasename, l as stripBasename, m as createLocation, n as createKey, o as createPath, p as addEventListener, q as removeEventListener, r as isExtraneousPopstateEvent, s as supportsGoWithoutReloadUsingHash, t as stripLeadingSlash, u as locationsAreEqual } from './chunk-4f14aa24.js';
var Node;
(function (Node) {
    var ErrorType;
    (function (ErrorType) {
        ErrorType["ERROR"] = "error";
    })(ErrorType = Node.ErrorType || (Node.ErrorType = {}));
    var MethodName;
    (function (MethodName) {
        MethodName["GET_APP_INSTANCES"] = "getAppInstances";
        MethodName["GET_PROPOSED_APP_INSTANCES"] = "getProposedAppInstances";
        MethodName["PROPOSE_INSTALL"] = "proposeInstall";
        MethodName["PROPOSE_INSTALL_VIRTUAL"] = "proposeInstallVirtual";
        MethodName["REJECT_INSTALL"] = "rejectInstall";
        MethodName["INSTALL"] = "install";
        MethodName["INSTALL_VIRTUAL"] = "installVirtual";
        MethodName["GET_STATE"] = "getState";
        MethodName["GET_APP_INSTANCE_DETAILS"] = "getAppInstanceDetails";
        MethodName["TAKE_ACTION"] = "takeAction";
        MethodName["UNINSTALL"] = "uninstall";
        MethodName["UNINSTALL_VIRTUAL"] = "uninstallVirtual";
        MethodName["PROPOSE_STATE"] = "proposeState";
        MethodName["ACCEPT_STATE"] = "acceptState";
        MethodName["REJECT_STATE"] = "rejectState";
        MethodName["CREATE_MULTISIG"] = "createMultisig";
        MethodName["GET_CHANNEL_ADDRESSES"] = "getChannelAddresses";
        MethodName["MATCHMAKE"] = "matchmake";
    })(MethodName = Node.MethodName || (Node.MethodName = {}));
    var EventName;
    (function (EventName) {
        EventName["INSTALL"] = "installEvent";
        EventName["REJECT_INSTALL"] = "rejectInstallEvent";
        EventName["UPDATE_STATE"] = "updateStateEvent";
        EventName["UNINSTALL"] = "uninstallEvent";
        EventName["PROPOSE_STATE"] = "proposeStateEvent";
        EventName["REJECT_STATE"] = "rejectStateEvent";
        EventName["CREATE_MULTISIG"] = "createMultisigEvent";
        EventName["MATCH_MADE"] = "matchmade";
    })(EventName = Node.EventName || (Node.EventName = {}));
})(Node || (Node = {}));
var NodeProvider = /** @class */ (function () {
    function NodeProvider() {
        this.isConnected = false;
        this.callback = function () { };
    }
    NodeProvider.prototype.onMessage = function (callback) {
        this.callback = callback;
    };
    NodeProvider.prototype.sendMessage = function (message) {
        if (!this.isConnected) {
            throw new Error("It's not possible to use postMessage() before the NodeProvider is connected. Call the connect() method first.");
        }
        var appInstanceId = "app-instance-" + new Date().valueOf();
        switch (message.type) {
            case Node.MethodName.PROPOSE_INSTALL_VIRTUAL:
                this.sendCallback({
                    type: Node.MethodName.PROPOSE_INSTALL_VIRTUAL,
                    result: { appInstanceId: appInstanceId },
                    requestId: message.requestId
                }, 100);
                this.sendCallback({
                    type: Node.EventName.INSTALL,
                    data: { appInstanceId: appInstanceId }
                }, 5000);
                break;
            case Node.MethodName.GET_APP_INSTANCE_DETAILS:
                this.sendCallback({
                    type: Node.MethodName.GET_APP_INSTANCE_DETAILS,
                    result: { appInstance: { id: message.params.appInstanceId } },
                    requestId: message.requestId
                }, 1);
                break;
            default:
                console.error("Unhandled message in MockNodeProvider:", message);
        }
    };
    NodeProvider.prototype.sendCallback = function (message, timeout) {
        var _this = this;
        setTimeout(function () {
            _this.callback(message);
        }, timeout);
    };
    NodeProvider.prototype.connect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                if (this.isConnected) {
                    console.warn("NodeProvider is already connected.");
                    return [2 /*return*/, Promise.resolve(this)];
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        return setTimeout(function () {
                            _this.isConnected = true;
                            return resolve(_this);
                        }, 1000);
                    })];
            });
        });
    };
    return NodeProvider;
}());
var bn = ethers.utils.bigNumberify;
var AppProvider = /** @class */ (function () {
    function AppProvider() {
        var _this = this;
        this.el = {};
        this.history = {};
        this.updateAppInstance = function () { };
        this.updateAppFactory = function () { };
        this.updateCfProvider = function () { };
        this.updateIntermediary = function () { };
        this.updateUIState = function () { };
        this.goToGame = function () { };
        this.highRoller = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, ({
                        playerFirstRoll: [0, 0],
                        playerSecondRoll: [0, 0]
                    })];
            });
        }); };
        this.generateRandomRoll = function () { return [0, 0]; };
        this.highRollerState = {};
        this.gameState = GameState.Play;
        this.myRoll = [1, 1];
        this.myScore = 0;
        this.opponentRoll = [1, 1];
        this.opponentScore = 0;
        this.nodeProvider = {};
        this.cfProvider = {};
        this.appFactory = {};
        this.appInstance = {};
        this.intermediary = "";
    }
    AppProvider.prototype.componentWillLoad = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var params;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = new URLSearchParams(window.location.search);
                        this.nodeProvider = !params.get("standalone")
                            ? new cf.NodeProvider()
                            : new NodeProvider();
                        return [4 /*yield*/, this.nodeProvider.connect()];
                    case 1:
                        _a.sent();
                        this.setupCfProvider();
                        return [2 /*return*/];
                }
            });
        });
    };
    AppProvider.prototype.setupCfProvider = function () {
        this.cfProvider = new cf.Provider(this.nodeProvider);
        this.cfProvider.on("chan_updateState", this.onUpdateState.bind(this));
        this.cfProvider.on("chan_uninstall", this.onUninstall.bind(this));
        this.cfProvider.on("chan_installVirtual", this.onInstall.bind(this));
        var highRollerAppDefinitionAddr = "0x144F1A5C2db59B58f2c73d09A2acb27a57E47618";
        this.appFactory = new cf.AppFactory(highRollerAppDefinitionAddr, {
            actionEncoding: "tuple(uint8 actionType, uint256 number, bytes32 actionHash)",
            stateEncoding: "\n          tuple(\n            uint8 stage,\n            bytes32 salt,\n            bytes32 commitHash,\n            uint256 playerFirstNumber,\n            uint256 playerSecondNumber,\n            uint256 versionNumber\n          )\n        "
        }, this.cfProvider);
        this.updateAppFactory(this.appFactory);
        this.updateCfProvider(this.cfProvider);
    };
    AppProvider.prototype.isReadyForHighRoller = function (state) {
        return (bn(state.playerFirstNumber).toNumber() &&
            bn(state.playerSecondNumber).toNumber() &&
            state.stage === HighRollerStage.P1_REVEALED_NUM);
    };
    AppProvider.prototype.onUpdateState = function (_a) {
        var data = _a.data;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var newState, state, myScore, opponentScore, gameState, rolls, myRoll, opponentRoll, totalMyRoll, totalOpponentRoll, highRollerState, newUIState;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        newState = data.newState;
                        state = Object.assign({}, newState, { playerFirstNumber: this.highRollerState.playerFirstNumber || newState["playerFirstNumber"] });
                        console.log("playerFirstNumber", state.playerFirstNumber, "playerSecondNumber", state.playerSecondNumber);
                        if (!(state.stage === HighRollerStage.P2_COMMITTED_TO_NUM)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.appInstance.takeAction({
                                actionType: HighRollerActionType.REVEAL_NUM,
                                actionHash: this.highRollerState.salt,
                                number: state.playerFirstNumber
                            })];
                    case 1: return [2 /*return*/, _b.sent()];
                    case 2:
                        if (!this.isReadyForHighRoller(state)) {
                            this.updateUIState({ highRollerState: state });
                            return [2 /*return*/];
                        }
                        myScore = this.myScore;
                        opponentScore = this.opponentScore;
                        return [4 /*yield*/, this.highRoller(state.playerFirstNumber, state.playerSecondNumber)];
                    case 3:
                        rolls = _b.sent();
                        myRoll = rolls.playerSecondRoll;
                        opponentRoll = rolls.playerFirstRoll;
                        totalMyRoll = myRoll[0] + myRoll[1];
                        totalOpponentRoll = opponentRoll[0] + opponentRoll[1];
                        if (totalMyRoll > totalOpponentRoll) {
                            myScore = this.myScore + 1;
                            gameState = GameState.Won;
                        }
                        else if (totalMyRoll < totalOpponentRoll) {
                            opponentScore += 1;
                            gameState = GameState.Lost;
                        }
                        else {
                            gameState = GameState.Tie;
                        }
                        highRollerState = state;
                        newUIState = {
                            myRoll: myRoll,
                            opponentRoll: opponentRoll,
                            myScore: myScore,
                            opponentScore: opponentScore,
                            gameState: gameState,
                            highRollerState: highRollerState
                        };
                        this.updateUIState(newUIState);
                        if (!(state.stage === HighRollerStage.P1_REVEALED_NUM)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.appInstance.uninstall(this.intermediary)];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    AppProvider.prototype.onInstall = function (data) {
        this.updateAppInstance(data.data.appInstance);
        this.goToGame(this.history);
    };
    AppProvider.prototype.onUninstall = function (data) { };
    AppProvider.prototype.render = function () {
        return h("slot", null);
    };
    Object.defineProperty(AppProvider, "is", {
        get: function () { return "app-provider"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppProvider, "properties", {
        get: function () {
            return {
                "appFactory": {
                    "type": "Any",
                    "attr": "app-factory",
                    "mutable": true
                },
                "appInstance": {
                    "type": "Any",
                    "attr": "app-instance",
                    "mutable": true
                },
                "cfProvider": {
                    "type": "Any",
                    "attr": "cf-provider",
                    "mutable": true
                },
                "el": {
                    "elementRef": true
                },
                "gameState": {
                    "type": Number,
                    "attr": "game-state"
                },
                "generateRandomRoll": {
                    "type": "Any",
                    "attr": "generate-random-roll"
                },
                "goToGame": {
                    "type": "Any",
                    "attr": "go-to-game"
                },
                "highRoller": {
                    "type": "Any",
                    "attr": "high-roller"
                },
                "highRollerState": {
                    "type": "Any",
                    "attr": "high-roller-state"
                },
                "history": {
                    "type": "Any",
                    "attr": "history"
                },
                "intermediary": {
                    "type": String,
                    "attr": "intermediary"
                },
                "myRoll": {
                    "type": "Any",
                    "attr": "my-roll"
                },
                "myScore": {
                    "type": Number,
                    "attr": "my-score"
                },
                "nodeProvider": {
                    "type": "Any",
                    "attr": "node-provider",
                    "mutable": true
                },
                "opponentRoll": {
                    "type": "Any",
                    "attr": "opponent-roll"
                },
                "opponentScore": {
                    "type": Number,
                    "attr": "opponent-score"
                },
                "updateAppFactory": {
                    "type": "Any",
                    "attr": "update-app-factory"
                },
                "updateAppInstance": {
                    "type": "Any",
                    "attr": "update-app-instance"
                },
                "updateCfProvider": {
                    "type": "Any",
                    "attr": "update-cf-provider"
                },
                "updateIntermediary": {
                    "type": "Any",
                    "attr": "update-intermediary"
                },
                "updateUIState": {
                    "type": "Any",
                    "attr": "update-u-i-state"
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    return AppProvider;
}());
HighRollerUITunnel.injectProps(AppProvider, [
    "myRoll",
    "myScore",
    "opponentRoll",
    "opponentScore",
    "gameState",
    "updateUIState",
    "highRollerState"
]);
CounterfactualTunnel.injectProps(AppProvider, ["appInstance", "intermediary"]);
var solidityKeccak256 = ethers.utils.solidityKeccak256;
var HashZero = ethers.constants.HashZero;
var AppRoot = /** @class */ (function () {
    function AppRoot() {
        this.userDataReceived = false;
        this.history = {};
        var params = new URLSearchParams(window.location.search);
        this.state = {
            account: {},
            opponent: {},
            standalone: params.get("standalone") === "true" || false,
            appInstance: null,
            appFactory: null,
            cfProvider: null,
            intermediary: null,
            updateAppInstance: this.updateAppInstance.bind(this),
            updateAppFactory: this.updateAppFactory.bind(this),
            updateUser: this.updateAccount.bind(this),
            updateOpponent: this.updateOpponent.bind(this),
            updateCfProvider: this.updateCfProvider.bind(this),
            updateIntermediary: this.updateIntermediary.bind(this)
        };
        this.uiState = {
            myRoll: [0, 0],
            myScore: 0,
            opponentRoll: [0, 0],
            opponentScore: 0,
            gameState: GameState.Play,
            updateUIState: this.updateUIState.bind(this),
            highRoller: this.highRoller.bind(this),
            generateRandomRoll: this.generateRandomRoll.bind(this),
            highRollerState: {
                stage: HighRollerStage.WAITING_FOR_P1_COMMITMENT,
                salt: HashZero,
                commitHash: HashZero,
                playerFirstNumber: 0,
                playerSecondNumber: 0,
                versionNumber: 0
            }
        };
        window.addEventListener("popstate", function () {
            window.parent.postMessage("playground:send:dappRoute|" + location.hash, "*");
        });
    }
    AppRoot.prototype.setupPlaygroundMessageListeners = function () {
        var _this = this;
        window.addEventListener("message", function (event) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, data, account, _b, data, appInstance;
            return tslib_1.__generator(this, function (_c) {
                if (typeof event.data === "string" &&
                    event.data.startsWith("playground:response:user")) {
                    _a = event.data.split("|"), data = _a[1];
                    account = JSON.parse(data);
                    this.updateAccount(account);
                    this.userDataReceived = true;
                }
                if (typeof event.data === "string" &&
                    event.data.startsWith("playground:response:appInstance")) {
                    _b = event.data.split("|"), data = _b[1];
                    if (data) {
                        console.log("Received playground appInstance: ", data);
                        appInstance = JSON.parse(data).appInstance;
                        this.updateAppInstance(appInstance);
                        this.updateOpponent({
                            attributes: {
                                nodeAddress: this.state.appInstance.initialState.initiatorAddress
                            }
                        });
                        this.goToWaitingRoom(this.history);
                    }
                }
                return [2 /*return*/];
            });
        }); });
    };
    AppRoot.prototype.componentWillLoad = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.setupPlaygroundMessageListeners();
                return [2 /*return*/];
            });
        });
    };
    AppRoot.prototype.componentDidLoad = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mockAccount;
            return tslib_1.__generator(this, function (_a) {
                window.parent.postMessage("playground:request:user", "*");
                if (this.state.standalone) {
                    mockAccount = {
                        user: {
                            address: "0xc60b9023bb8dc153b4046977328ce79af12a77e0",
                            email: "alon2@example.com",
                            id: "687297bc-8014-4c82-8cee-3b7ca7db09d4",
                            username: "MyName"
                        },
                        multisigAddress: "0x9499ac5A66c36447e535d252c049304D80961CED"
                    };
                    this.updateAccount(mockAccount);
                    this.userDataReceived = true;
                }
                return [2 /*return*/];
            });
        });
    };
    AppRoot.prototype.receiveRouterHistory = function (history) {
        this.history = history;
    };
    AppRoot.prototype.updateAccount = function (account) {
        this.state = Object.assign({}, this.state, { account: account });
        ga("set", "userId", account.user.id);
    };
    AppRoot.prototype.updateOpponent = function (opponent) {
        this.state = Object.assign({}, this.state, { opponent: opponent });
    };
    AppRoot.prototype.updateAppInstance = function (appInstance) {
        this.state = Object.assign({}, this.state, { appInstance: appInstance });
        console.log("appInstance updated", appInstance);
    };
    AppRoot.prototype.updateAppFactory = function (appFactory) {
        this.state = Object.assign({}, this.state, { appFactory: appFactory });
    };
    AppRoot.prototype.updateCfProvider = function (cfProvider) {
        this.state = Object.assign({}, this.state, { cfProvider: cfProvider });
        console.log("CFProvider instance updated");
    };
    AppRoot.prototype.updateIntermediary = function (intermediary) {
        this.state = Object.assign({}, this.state, { intermediary: intermediary });
    };
    AppRoot.prototype.updateUIState = function (state) {
        this.uiState = Object.assign({}, this.uiState, state);
        console.log("%cNew UI state detected", "font-size: 14px; color: red");
        console.log("    ", this.uiState);
    };
    AppRoot.prototype.generateRandomRoll = function () {
        return [
            1 + Math.floor(Math.random() * Math.floor(6)),
            1 + Math.floor(Math.random() * Math.floor(6))
        ];
    };
    AppRoot.prototype.highRoller = function (num1, num2) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var randomness, abi, provider, contractAddress, contract, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        randomness = solidityKeccak256(["uint256"], [num1.mul(num2)]);
                        abi = [
                            "\n      function highRoller(bytes32 randomness)\n        public\n        pure\n        returns(uint8 playerFirstTotal, uint8 playerSecondTotal)\n    "
                        ];
                        provider = new ethers.providers.Web3Provider(web3.currentProvider);
                        contractAddress = "0x144F1A5C2db59B58f2c73d09A2acb27a57E47618";
                        contract = new ethers.Contract(contractAddress, abi, provider);
                        return [4 /*yield*/, contract.highRoller(randomness)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, {
                                playerFirstRoll: this.getDieNumbers(result[0]),
                                playerSecondRoll: this.getDieNumbers(result[1])
                            }];
                }
            });
        });
    };
    AppRoot.prototype.getDieNumbers = function (totalSum) {
        if (totalSum === 12) {
            return [6, 6];
        }
        if (totalSum > 2 && totalSum < 12) {
            return [Math.floor(totalSum / 2), Math.ceil(totalSum / 2)];
        }
        if (totalSum > 2 && totalSum % 2 === 0) {
            return [Math.floor(totalSum / 2) - 1, Math.ceil(totalSum / 2) + 1];
        }
        return [totalSum / 2, totalSum / 2];
    };
    AppRoot.prototype.goToGame = function (history, isProposing) {
        if (isProposing === void 0) { isProposing = true; }
        history.push({
            pathname: "/game",
            state: {
                isProposing: isProposing,
                betAmount: ethers.utils.formatEther(this.state.appInstance.initiatorDeposit)
            },
            query: {},
            key: ""
        });
    };
    AppRoot.prototype.goToWaitingRoom = function (history) {
        history.push("/waiting", {
            isProposing: false,
            betAmount: ethers.utils.formatEther(this.state.appInstance.responderDeposit)
        });
    };
    AppRoot.prototype.render = function () {
        return this.userDataReceived ? (h("div", { class: "height-100" }, h("main", { class: "height-100" }, h(CounterfactualTunnel.Provider, { state: this.state }, h(HighRollerUITunnel.Provider, { state: this.uiState }, h("stencil-router", { historyType: "hash" }, h("stencil-route-switch", { scrollTopOffset: 0 }, h("app-provider", { updateAppInstance: this.state.updateAppInstance.bind(this), updateAppFactory: this.state.updateAppFactory.bind(this), updateCfProvider: this.state.updateCfProvider.bind(this), updateIntermediary: this.state.updateIntermediary.bind(this), updateUIState: this.uiState.updateUIState.bind(this), highRoller: this.uiState.highRoller.bind(this), generateRandomRoll: this.uiState.generateRandomRoll.bind(this), goToGame: this.goToGame.bind(this), history: this.history }, h("stencil-route", { url: "/", exact: true, component: "app-logo", componentProps: {
                cfProvider: this.state.cfProvider,
                appInstance: this.state.appInstance,
                goToWaitingRoom: this.goToWaitingRoom,
                updateAppInstance: this.updateAppInstance,
                provideRouterHistory: this.receiveRouterHistory.bind(this)
            } }), h("stencil-route", { url: "/wager", component: "app-wager", componentProps: {
                updateOpponent: this.state.updateOpponent
            } }), h("stencil-route", { url: "/game", component: "app-game" }), h("stencil-route", { url: "/waiting", component: "app-waiting", componentProps: {
                cfProvider: this.state.cfProvider,
                appInstance: this.state.appInstance,
                goToWaitingRoom: this.goToWaitingRoom,
                updateAppInstance: this.updateAppInstance,
                history: this.history
            } }), h("stencil-route", { url: "/accept-invite", component: "app-accept-invite" }))))))))) : (h("h1", { class: "App message" }, "connecting...."));
    };
    Object.defineProperty(AppRoot, "is", {
        get: function () { return "app-root"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppRoot, "encapsulation", {
        get: function () { return "shadow"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppRoot, "properties", {
        get: function () {
            return {
                "history": {
                    "state": true
                },
                "state": {
                    "type": "Any",
                    "attr": "state",
                    "mutable": true
                },
                "uiState": {
                    "type": "Any",
                    "attr": "ui-state",
                    "mutable": true
                },
                "userDataReceived": {
                    "state": true
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppRoot, "style", {
        get: function () { return "/**style-placeholder:app-root:**/"; },
        enumerable: true,
        configurable: true
    });
    return AppRoot;
}());
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            }
        }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Route = /** @class */ (function () {
    function Route() {
        this.group = null;
        this.match = null;
        this.componentProps = {};
        this.exact = false;
        this.scrollOnNextRender = false;
        this.previousMatch = null;
    }
    Route.prototype.computeMatch = function (newLocation) {
        var isGrouped = this.group != null || (this.el.parentElement != null && this.el.parentElement.tagName.toLowerCase() === "stencil-route-switch");
        if (!newLocation || isGrouped) {
            return;
        }
        this.previousMatch = this.match;
        return this.match = matchPath(newLocation.pathname, {
            path: this.url,
            exact: this.exact,
            strict: true
        });
    };
    Route.prototype.loadCompleted = function () {
        return __awaiter(this, void 0, void 0, function () {
            var routeViewOptions;
            return tslib_1.__generator(this, function (_a) {
                routeViewOptions = {};
                if (this.history && this.history.location.hash) {
                    routeViewOptions = {
                        scrollToId: this.history.location.hash.substr(1)
                    };
                }
                else if (this.scrollTopOffset) {
                    routeViewOptions = {
                        scrollTopOffset: this.scrollTopOffset
                    };
                }
                if (typeof this.componentUpdated === "function") {
                    this.componentUpdated(routeViewOptions);
                }
                else if (this.match && !matchesAreEqual(this.match, this.previousMatch) && this.routeViewsUpdated) {
                    this.routeViewsUpdated(routeViewOptions);
                }
                return [2 /*return*/];
            });
        });
    };
    Route.prototype.componentDidUpdate = function () {
        return __awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loadCompleted()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Route.prototype.componentDidLoad = function () {
        return __awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loadCompleted()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Route.prototype.render = function () {
        if (!this.match || !this.history) {
            return null;
        }
        var childProps = Object.assign({}, this.componentProps, { history: this.history, match: this.match });
        if (this.routeRender) {
            return this.routeRender(Object.assign({}, childProps, { component: this.component }));
        }
        if (this.component) {
            var ChildComponent = this.component;
            return (h(ChildComponent, Object.assign({}, childProps)));
        }
    };
    Object.defineProperty(Route, "is", {
        get: function () { return "stencil-route"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Route, "properties", {
        get: function () {
            return {
                "component": {
                    "type": String,
                    "attr": "component"
                },
                "componentProps": {
                    "type": "Any",
                    "attr": "component-props"
                },
                "componentUpdated": {
                    "type": "Any",
                    "attr": "component-updated"
                },
                "el": {
                    "elementRef": true
                },
                "exact": {
                    "type": Boolean,
                    "attr": "exact"
                },
                "group": {
                    "type": String,
                    "attr": "group",
                    "reflectToAttr": true
                },
                "history": {
                    "type": "Any",
                    "attr": "history"
                },
                "historyType": {
                    "type": String,
                    "attr": "history-type"
                },
                "location": {
                    "type": "Any",
                    "attr": "location",
                    "watchCallbacks": ["computeMatch"]
                },
                "match": {
                    "type": "Any",
                    "attr": "match",
                    "mutable": true
                },
                "routeRender": {
                    "type": "Any",
                    "attr": "route-render"
                },
                "routeViewsUpdated": {
                    "type": "Any",
                    "attr": "route-views-updated"
                },
                "scrollTopOffset": {
                    "type": Number,
                    "attr": "scroll-top-offset"
                },
                "url": {
                    "type": String,
                    "attr": "url"
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Route, "style", {
        get: function () { return "/**style-placeholder:stencil-route:**/"; },
        enumerable: true,
        configurable: true
    });
    return Route;
}());
ActiveRouter.injectProps(Route, [
    "location",
    "history",
    "historyType",
    "routeViewsUpdated"
]);
function uuidv4() {
    return ([1e7].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function (c) {
        var random = window.crypto.getRandomValues(new Uint8Array(1));
        return (c ^ random[0] & 15 >> c / 4).toString(16);
    });
}
var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            }
        }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getUniqueId() {
    if (window.crypto) {
        return uuidv4();
    }
    return ((Math.random() * 100000000000000000).toString().match(/.{4}/g) || []).join("-");
}
function getMatch(pathname, url, exact) {
    return matchPath(pathname, {
        path: url,
        exact: exact,
        strict: true
    });
}
function isHTMLStencilRouteElement(element) {
    return element.tagName.toLowerCase() === "stencil-route";
}
var RouteSwitch = /** @class */ (function () {
    function RouteSwitch() {
        this.group = getUniqueId();
        this.subscribers = [];
    }
    RouteSwitch.prototype.componentWillLoad = function () {
        if (this.location != null) {
            this.regenerateSubscribers(this.location);
        }
    };
    RouteSwitch.prototype.regenerateSubscribers = function (newLocation) {
        return __awaiter$1(this, void 0, void 0, function () {
            var newActiveIndex, activeChild;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                if (newLocation == null) {
                    return [2 /*return*/];
                }
                newActiveIndex = -1;
                this.subscribers = Array.prototype.slice.call(this.el.children)
                    .filter(isHTMLStencilRouteElement)
                    .map(function (childElement, index) {
                    var match = getMatch(newLocation.pathname, childElement.url, childElement.exact);
                    if (match && newActiveIndex === -1) {
                        newActiveIndex = index;
                    }
                    return {
                        el: childElement,
                        match: match
                    };
                });
                if (newActiveIndex === -1) {
                    return [2 /*return*/];
                }
                if (this.activeIndex === newActiveIndex) {
                    this.subscribers[newActiveIndex].el.match = this.subscribers[newActiveIndex].match;
                    return [2 /*return*/];
                }
                this.activeIndex = newActiveIndex;
                activeChild = this.subscribers[this.activeIndex];
                if (this.scrollTopOffset) {
                    activeChild.el.scrollTopOffset = this.scrollTopOffset;
                }
                activeChild.el.group = this.group;
                activeChild.el.match = activeChild.match;
                activeChild.el.componentUpdated = function (routeViewUpdatedOptions) {
                    _this.queue.write(function () {
                        _this.subscribers.forEach(function (child, index) {
                            child.el.componentUpdated = undefined;
                            if (index === _this.activeIndex) {
                                return child.el.style.display = "";
                            }
                            if (_this.scrollTopOffset) {
                                child.el.scrollTopOffset = _this.scrollTopOffset;
                            }
                            child.el.group = _this.group;
                            child.el.match = null;
                            child.el.style.display = "none";
                        });
                    });
                    if (_this.routeViewsUpdated) {
                        _this.routeViewsUpdated(Object.assign({ scrollTopOffset: _this.scrollTopOffset }, routeViewUpdatedOptions));
                    }
                };
                return [2 /*return*/];
            });
        });
    };
    RouteSwitch.prototype.render = function () {
        return (h("slot", null));
    };
    Object.defineProperty(RouteSwitch, "is", {
        get: function () { return "stencil-route-switch"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouteSwitch, "properties", {
        get: function () {
            return {
                "el": {
                    "elementRef": true
                },
                "group": {
                    "type": String,
                    "attr": "group",
                    "reflectToAttr": true
                },
                "location": {
                    "type": "Any",
                    "attr": "location",
                    "watchCallbacks": ["regenerateSubscribers"]
                },
                "queue": {
                    "context": "queue"
                },
                "routeViewsUpdated": {
                    "type": "Any",
                    "attr": "route-views-updated"
                },
                "scrollTopOffset": {
                    "type": Number,
                    "attr": "scroll-top-offset"
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    return RouteSwitch;
}());
ActiveRouter.injectProps(RouteSwitch, [
    "location",
    "routeViewsUpdated"
]);
function invariant(value) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (!value) {
        console.error.apply(console, args);
    }
}
function warning(value) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (!value) {
        console.warn.apply(console, args);
    }
}
var createTransitionManager = function () {
    var prompt;
    var setPrompt = function (nextPrompt) {
        warning(prompt == null, 'A history supports only one prompt at a time');
        prompt = nextPrompt;
        return function () {
            if (prompt === nextPrompt) {
                prompt = null;
            }
        };
    };
    var confirmTransitionTo = function (location, action, getUserConfirmation, callback) {
        if (prompt != null) {
            var result = typeof prompt === 'function' ? prompt(location, action) : prompt;
            if (typeof result === 'string') {
                if (typeof getUserConfirmation === 'function') {
                    getUserConfirmation(result, callback);
                }
                else {
                    warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');
                    callback(true);
                }
            }
            else {
                callback(result !== false);
            }
        }
        else {
            callback(true);
        }
    };
    var listeners = [];
    var appendListener = function (fn) {
        var isActive = true;
        var listener = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (isActive) {
                fn.apply(void 0, args);
            }
        };
        listeners.push(listener);
        return function () {
            isActive = false;
            listeners = listeners.filter(function (item) { return item !== listener; });
        };
    };
    var notifyListeners = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        listeners.forEach(function (listener) { return listener.apply(void 0, args); });
    };
    return {
        setPrompt: setPrompt,
        confirmTransitionTo: confirmTransitionTo,
        appendListener: appendListener,
        notifyListeners: notifyListeners
    };
};
var createScrollHistory = function (applicationScrollKey) {
    if (applicationScrollKey === void 0) { applicationScrollKey = 'scrollPositions'; }
    var scrollPositions = new Map();
    if (storageAvailable('sessionStorage')) {
        var scrollData = window.sessionStorage.getItem(applicationScrollKey);
        scrollPositions = scrollData ?
            new Map(JSON.parse(scrollData)) :
            scrollPositions;
    }
    if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }
    function set(key, value) {
        scrollPositions.set(key, value);
        if (storageAvailable('sessionStorage')) {
            var arrayData_1 = [];
            scrollPositions.forEach(function (value, key) {
                arrayData_1.push([key, value]);
            });
            window.sessionStorage.setItem('scrollPositions', JSON.stringify(arrayData_1));
        }
    }
    function get(key) {
        return scrollPositions.get(key);
    }
    function has(key) {
        return scrollPositions.has(key);
    }
    function capture(key) {
        set(key, [window.scrollX, window.scrollY]);
    }
    return {
        set: set,
        get: get,
        has: has,
        capture: capture
    };
};
var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';
var getHistoryState = function () {
    try {
        return window.history.state || {};
    }
    catch (e) {
        return {};
    }
};
var createBrowserHistory = function (props) {
    if (props === void 0) { props = {}; }
    invariant(canUseDOM, 'Browser history needs a DOM');
    var globalHistory = window.history;
    var canUseHistory = supportsHistory();
    var needsHashChangeListener = !supportsPopStateOnHashChange();
    var scrollHistory = createScrollHistory();
    var forceRefresh = (props.forceRefresh != null) ? props.forceRefresh : false;
    var getUserConfirmation = (props.getUserConfirmation != null) ? props.getUserConfirmation : getConfirmation;
    var keyLength = (props.keyLength != null) ? props.keyLength : 6;
    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
    var getDOMLocation = function (historyState) {
        historyState = historyState || {};
        var key = historyState.key, state = historyState.state;
        var _a = window.location, pathname = _a.pathname, search = _a.search, hash = _a.hash;
        var path = pathname + search + hash;
        warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +
            'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
        if (basename) {
            path = stripBasename(path, basename);
        }
        return createLocation(path, state, key || createKey(keyLength));
    };
    var transitionManager = createTransitionManager();
    var setState = function (nextState) {
        scrollHistory.capture(history.location.key);
        Object.assign(history, nextState);
        history.location.scrollPosition = scrollHistory.get(history.location.key);
        history.length = globalHistory.length;
        transitionManager.notifyListeners(history.location, history.action);
    };
    var handlePopState = function (event) {
        if (isExtraneousPopstateEvent(event)) {
            return;
        }
        handlePop(getDOMLocation(event.state));
    };
    var handleHashChange = function () {
        handlePop(getDOMLocation(getHistoryState()));
    };
    var forceNextPop = false;
    var handlePop = function (location) {
        if (forceNextPop) {
            forceNextPop = false;
            setState();
        }
        else {
            var action_1 = 'POP';
            transitionManager.confirmTransitionTo(location, action_1, getUserConfirmation, function (ok) {
                if (ok) {
                    setState({ action: action_1, location: location });
                }
                else {
                    revertPop(location);
                }
            });
        }
    };
    var revertPop = function (fromLocation) {
        var toLocation = history.location;
        var toIndex = allKeys.indexOf(toLocation.key);
        if (toIndex === -1) {
            toIndex = 0;
        }
        var fromIndex = allKeys.indexOf(fromLocation.key);
        if (fromIndex === -1) {
            fromIndex = 0;
        }
        var delta = toIndex - fromIndex;
        if (delta) {
            forceNextPop = true;
            go(delta);
        }
    };
    var initialLocation = getDOMLocation(getHistoryState());
    var allKeys = [initialLocation.key];
    var createHref = function (location) {
        return basename + createPath(location);
    };
    var push = function (path, state) {
        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +
            'argument is a location-like object that already has state; it is ignored');
        var action = 'PUSH';
        var location = createLocation(path, state, createKey(keyLength), history.location);
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
            if (!ok) {
                return;
            }
            var href = createHref(location);
            var key = location.key, state = location.state;
            if (canUseHistory) {
                globalHistory.pushState({ key: key, state: state }, undefined, href);
                if (forceRefresh) {
                    window.location.href = href;
                }
                else {
                    var prevIndex = allKeys.indexOf(history.location.key);
                    var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                    nextKeys.push(location.key);
                    allKeys = nextKeys;
                    setState({ action: action, location: location });
                }
            }
            else {
                warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');
                window.location.href = href;
            }
        });
    };
    var replace = function (path, state) {
        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +
            'argument is a location-like object that already has state; it is ignored');
        var action = 'REPLACE';
        var location = createLocation(path, state, createKey(keyLength), history.location);
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
            if (!ok) {
                return;
            }
            var href = createHref(location);
            var key = location.key, state = location.state;
            if (canUseHistory) {
                globalHistory.replaceState({ key: key, state: state }, undefined, href);
                if (forceRefresh) {
                    window.location.replace(href);
                }
                else {
                    var prevIndex = allKeys.indexOf(history.location.key);
                    if (prevIndex !== -1) {
                        allKeys[prevIndex] = location.key;
                    }
                    setState({ action: action, location: location });
                }
            }
            else {
                warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');
                window.location.replace(href);
            }
        });
    };
    var go = function (n) {
        globalHistory.go(n);
    };
    var goBack = function () { return go(-1); };
    var goForward = function () { return go(1); };
    var listenerCount = 0;
    var checkDOMListeners = function (delta) {
        listenerCount += delta;
        if (listenerCount === 1) {
            addEventListener(window, PopStateEvent, handlePopState);
            if (needsHashChangeListener) {
                addEventListener(window, HashChangeEvent, handleHashChange);
            }
        }
        else if (listenerCount === 0) {
            removeEventListener(window, PopStateEvent, handlePopState);
            if (needsHashChangeListener) {
                removeEventListener(window, HashChangeEvent, handleHashChange);
            }
        }
    };
    var isBlocked = false;
    var block = function (prompt) {
        if (prompt === void 0) { prompt = ''; }
        var unblock = transitionManager.setPrompt(prompt);
        if (!isBlocked) {
            checkDOMListeners(1);
            isBlocked = true;
        }
        return function () {
            if (isBlocked) {
                isBlocked = false;
                checkDOMListeners(-1);
            }
            return unblock();
        };
    };
    var listen = function (listener) {
        var unlisten = transitionManager.appendListener(listener);
        checkDOMListeners(1);
        return function () {
            checkDOMListeners(-1);
            unlisten();
        };
    };
    var history = {
        length: globalHistory.length,
        action: 'POP',
        location: initialLocation,
        createHref: createHref,
        push: push,
        replace: replace,
        go: go,
        goBack: goBack,
        goForward: goForward,
        block: block,
        listen: listen
    };
    return history;
};
var HashChangeEvent$1 = 'hashchange';
var HashPathCoders = {
    hashbang: {
        encodePath: function (path) { return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path); },
        decodePath: function (path) { return path.charAt(0) === '!' ? path.substr(1) : path; }
    },
    noslash: {
        encodePath: stripLeadingSlash,
        decodePath: addLeadingSlash
    },
    slash: {
        encodePath: addLeadingSlash,
        decodePath: addLeadingSlash
    }
};
var getHashPath = function () {
    var href = window.location.href;
    var hashIndex = href.indexOf('#');
    return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};
var pushHashPath = function (path) { return (window.location.hash = path); };
var replaceHashPath = function (path) {
    var hashIndex = window.location.href.indexOf('#');
    window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};
var createHashHistory = function (props) {
    if (props === void 0) { props = {}; }
    invariant(canUseDOM, 'Hash history needs a DOM');
    var globalHistory = window.history;
    var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
    var keyLength = (props.keyLength != null) ? props.keyLength : 6;
    var _a = props.getUserConfirmation, getUserConfirmation = _a === void 0 ? getConfirmation : _a, _b = props.hashType, hashType = _b === void 0 ? 'slash' : _b;
    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
    var _c = HashPathCoders[hashType], encodePath = _c.encodePath, decodePath = _c.decodePath;
    var getDOMLocation = function () {
        var path = decodePath(getHashPath());
        warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +
            'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');
        if (basename) {
            path = stripBasename(path, basename);
        }
        return createLocation(path, undefined, createKey(keyLength));
    };
    var transitionManager = createTransitionManager();
    var setState = function (nextState) {
        Object.assign(history, nextState);
        history.length = globalHistory.length;
        transitionManager.notifyListeners(history.location, history.action);
    };
    var forceNextPop = false;
    var ignorePath = null;
    var handleHashChange = function () {
        var path = getHashPath();
        var encodedPath = encodePath(path);
        if (path !== encodedPath) {
            replaceHashPath(encodedPath);
        }
        else {
            var location = getDOMLocation();
            var prevLocation = history.location;
            if (!forceNextPop && locationsAreEqual(prevLocation, location)) {
                return;
            }
            if (ignorePath === createPath(location)) {
                return;
            }
            ignorePath = null;
            handlePop(location);
        }
    };
    var handlePop = function (location) {
        if (forceNextPop) {
            forceNextPop = false;
            setState();
        }
        else {
            var action_2 = 'POP';
            transitionManager.confirmTransitionTo(location, action_2, getUserConfirmation, function (ok) {
                if (ok) {
                    setState({ action: action_2, location: location });
                }
                else {
                    revertPop(location);
                }
            });
        }
    };
    var revertPop = function (fromLocation) {
        var toLocation = history.location;
        var toIndex = allPaths.lastIndexOf(createPath(toLocation));
        if (toIndex === -1) {
            toIndex = 0;
        }
        var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
        if (fromIndex === -1) {
            fromIndex = 0;
        }
        var delta = toIndex - fromIndex;
        if (delta) {
            forceNextPop = true;
            go(delta);
        }
    };
    var path = getHashPath();
    var encodedPath = encodePath(path);
    if (path !== encodedPath) {
        replaceHashPath(encodedPath);
    }
    var initialLocation = getDOMLocation();
    var allPaths = [createPath(initialLocation)];
    var createHref = function (location) { return ('#' + encodePath(basename + createPath(location))); };
    var push = function (path, state) {
        warning(state === undefined, 'Hash history cannot push state; it is ignored');
        var action = 'PUSH';
        var location = createLocation(path, undefined, createKey(keyLength), history.location);
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
            if (!ok) {
                return;
            }
            var path = createPath(location);
            var encodedPath = encodePath(basename + path);
            var hashChanged = getHashPath() !== encodedPath;
            if (hashChanged) {
                ignorePath = path;
                pushHashPath(encodedPath);
                var prevIndex = allPaths.lastIndexOf(createPath(history.location));
                var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                nextPaths.push(path);
                allPaths = nextPaths;
                setState({ action: action, location: location });
            }
            else {
                warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');
                setState();
            }
        });
    };
    var replace = function (path, state) {
        warning(state === undefined, 'Hash history cannot replace state; it is ignored');
        var action = 'REPLACE';
        var location = createLocation(path, undefined, createKey(keyLength), history.location);
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
            if (!ok) {
                return;
            }
            var path = createPath(location);
            var encodedPath = encodePath(basename + path);
            var hashChanged = getHashPath() !== encodedPath;
            if (hashChanged) {
                ignorePath = path;
                replaceHashPath(encodedPath);
            }
            var prevIndex = allPaths.indexOf(createPath(history.location));
            if (prevIndex !== -1) {
                allPaths[prevIndex] = path;
            }
            setState({ action: action, location: location });
        });
    };
    var go = function (n) {
        warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');
        globalHistory.go(n);
    };
    var goBack = function () { return go(-1); };
    var goForward = function () { return go(1); };
    var listenerCount = 0;
    var checkDOMListeners = function (delta) {
        listenerCount += delta;
        if (listenerCount === 1) {
            addEventListener(window, HashChangeEvent$1, handleHashChange);
        }
        else if (listenerCount === 0) {
            removeEventListener(window, HashChangeEvent$1, handleHashChange);
        }
    };
    var isBlocked = false;
    var block = function (prompt) {
        if (prompt === void 0) { prompt = ''; }
        var unblock = transitionManager.setPrompt(prompt);
        if (!isBlocked) {
            checkDOMListeners(1);
            isBlocked = true;
        }
        return function () {
            if (isBlocked) {
                isBlocked = false;
                checkDOMListeners(-1);
            }
            return unblock();
        };
    };
    var listen = function (listener) {
        var unlisten = transitionManager.appendListener(listener);
        checkDOMListeners(1);
        return function () {
            checkDOMListeners(-1);
            unlisten();
        };
    };
    var history = {
        length: globalHistory.length,
        action: 'POP',
        location: initialLocation,
        createHref: createHref,
        push: push,
        replace: replace,
        go: go,
        goBack: goBack,
        goForward: goForward,
        block: block,
        listen: listen
    };
    return history;
};
var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            }
        }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getLocation(location, root) {
    var pathname = location.pathname.indexOf(root) == 0 ?
        "/" + location.pathname.slice(root.length) :
        location.pathname;
    return Object.assign({}, location, { pathname: pathname });
}
var HISTORIES = {
    "browser": createBrowserHistory,
    "hash": createHashHistory
};
var Router = /** @class */ (function () {
    function Router() {
        var _this = this;
        this.root = "/";
        this.historyType = "browser";
        this.titleSuffix = "";
        this.routeViewsUpdated = function (options) {
            if (options === void 0) { options = {}; }
            if (options.scrollToId && _this.historyType === "browser") {
                var element = document.getElementById(options.scrollToId);
                if (element) {
                    return element.scrollIntoView();
                }
            }
            _this.scrollTo(options.scrollTopOffset || _this.scrollTopOffset);
        };
    }
    Router.prototype.componentWillLoad = function () {
        var _this = this;
        this.history = HISTORIES[this.historyType]();
        this.history.listen(function (location) { return __awaiter$2(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                location = getLocation(location, this.root);
                this.location = location;
                return [2 /*return*/];
            });
        }); });
        this.location = getLocation(this.history.location, this.root);
    };
    Router.prototype.scrollTo = function (scrollToLocation) {
        var _this = this;
        if (scrollToLocation == null || this.isServer || !this.history) {
            return;
        }
        if (this.history.action === "POP" && Array.isArray(this.history.location.scrollPosition)) {
            return this.queue.write(function () {
                if (_this.history && _this.history.location && Array.isArray(_this.history.location.scrollPosition)) {
                    window.scrollTo(_this.history.location.scrollPosition[0], _this.history.location.scrollPosition[1]);
                }
            });
        }
        return this.queue.write(function () {
            window.scrollTo(0, scrollToLocation);
        });
    };
    Router.prototype.render = function () {
        if (!this.location || !this.history) {
            return;
        }
        var state = {
            historyType: this.historyType,
            location: this.location,
            titleSuffix: this.titleSuffix,
            root: this.root,
            history: this.history,
            routeViewsUpdated: this.routeViewsUpdated
        };
        return (h(ActiveRouter.Provider, { state: state }, h("slot", null)));
    };
    Object.defineProperty(Router, "is", {
        get: function () { return "stencil-router"; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Router, "properties", {
        get: function () {
            return {
                "history": {
                    "state": true
                },
                "historyType": {
                    "type": String,
                    "attr": "history-type"
                },
                "isServer": {
                    "context": "isServer"
                },
                "location": {
                    "state": true
                },
                "queue": {
                    "context": "queue"
                },
                "root": {
                    "type": String,
                    "attr": "root"
                },
                "scrollTopOffset": {
                    "type": Number,
                    "attr": "scroll-top-offset"
                },
                "titleSuffix": {
                    "type": String,
                    "attr": "title-suffix"
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    return Router;
}());
export { AppProvider, AppRoot, Route as StencilRoute, RouteSwitch as StencilRouteSwitch, Router as StencilRouter };

{"moduleFile":{"sourceFilePath":"/home/arjun/repositories/counterfactual/monorepo/packages/dapp-high-roller/src/data/__mocks__/@stencil/state-tunnel.tsx","localImports":[],"externalImports":["@stencil/core"],"potentialCmpRefs":[{"tag":"context-consumer"}],"hasSlot":false,"hasSvg":false,"jsFilePath":"/home/arjun/repositories/counterfactual/monorepo/packages/dapp-high-roller/src/data/__mocks__/@stencil/state-tunnel.js"},"jsText":"var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nfunction defaultConsumerRender(subscribe, renderer) {\r\n    return h(\"context-consumer\", { subscribe: subscribe, renderer: renderer });\r\n}\r\nexport function createProviderConsumer(defaultState, consumerRender = defaultConsumerRender) {\r\n    const listeners = new Map();\r\n    let currentState = defaultState;\r\n    function notifyConsumers() {\r\n        listeners.forEach(updateListener);\r\n    }\r\n    function updateListener(fields, listener) {\r\n        if (Array.isArray(fields)) {\r\n            [...fields].forEach(fieldName => {\r\n                listener[fieldName] = currentState[fieldName];\r\n            });\r\n        }\r\n        else {\r\n            listener[fields] = Object.assign({}, currentState);\r\n        }\r\n        listener.forceUpdate();\r\n    }\r\n    function attachListener(propList) {\r\n        return (el) => {\r\n            if (listeners.has(el)) {\r\n                return;\r\n            }\r\n            listeners.set(el, propList);\r\n            updateListener(propList, el);\r\n        };\r\n    }\r\n    function subscribe(el, propList) {\r\n        attachListener(propList)(el);\r\n        return function () {\r\n            listeners.delete(el);\r\n        };\r\n    }\r\n    const provider = ({ state }, children) => {\r\n        currentState = state;\r\n        notifyConsumers();\r\n        return children;\r\n    };\r\n    const consumer = (props, children) => {\r\n        return consumerRender(subscribe, children[0]);\r\n    };\r\n    function wrapConsumer(childComponent, fieldList) {\r\n        const child = childComponent.is;\r\n        return (_a) => {\r\n            var { children } = _a, props = __rest(_a, [\"children\"]);\r\n            return (h(\"child\", Object.assign({ ref: attachListener(fieldList) }, props), children));\r\n        };\r\n    }\r\n    function injectProps(childComponent, fieldList) {\r\n        let unsubscribe = null;\r\n        const elementRefName = Object.keys(childComponent.properties).find(propName => {\r\n            return childComponent.properties[propName].elementRef === true;\r\n        });\r\n        if (elementRefName === undefined) {\r\n            throw new Error(`Please ensure that your Component ${childComponent.is} has an attribute with an \"@Element\" decorator. ` +\r\n                `This is required to be able to inject properties.`);\r\n        }\r\n        const prevComponentWillLoad = childComponent.prototype.componentWillLoad;\r\n        childComponent.prototype.componentWillLoad = function () {\r\n            unsubscribe = subscribe(this[elementRefName], fieldList);\r\n            if (prevComponentWillLoad) {\r\n                return prevComponentWillLoad.bind(this)();\r\n            }\r\n        };\r\n        const prevComponentDidUnload = childComponent.prototype.componentDidUnload;\r\n        childComponent.prototype.componentDidUnload = function () {\r\n            unsubscribe();\r\n            if (prevComponentDidUnload) {\r\n                return prevComponentDidUnload.bind(this)();\r\n            }\r\n        };\r\n    }\r\n    return {\r\n        wrapConsumer,\r\n        injectProps,\r\n        Provider: provider,\r\n        Consumer: consumer\r\n    };\r\n}\r\n"}
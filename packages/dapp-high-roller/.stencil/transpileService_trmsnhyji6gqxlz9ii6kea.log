{"moduleFile":{"sourceFilePath":"/home/arjun/repositories/counterfactual/monorepo/packages/dapp-high-roller/src/data/mock-node-provider.ts","localImports":["/home/arjun/repositories/counterfactual/monorepo/packages/dapp-high-roller/src/data/types"],"externalImports":[],"potentialCmpRefs":[],"hasSlot":false,"hasSvg":false,"jsFilePath":"/home/arjun/repositories/counterfactual/monorepo/packages/dapp-high-roller/src/data/mock-node-provider.js"},"jsText":"import { Node } from \"./types\";\r\nexport default class NodeProvider {\r\n    constructor() {\r\n        this.isConnected = false;\r\n        this.callback = () => { };\r\n    }\r\n    onMessage(callback) {\r\n        this.callback = callback;\r\n    }\r\n    sendMessage(message) {\r\n        if (!this.isConnected) {\r\n            throw new Error(\"It's not possible to use postMessage() before the NodeProvider is connected. Call the connect() method first.\");\r\n        }\r\n        const appInstanceId = `app-instance-${new Date().valueOf()}`;\r\n        switch (message.type) {\r\n            case Node.MethodName.PROPOSE_INSTALL_VIRTUAL:\r\n                this.sendCallback({\r\n                    type: Node.MethodName.PROPOSE_INSTALL_VIRTUAL,\r\n                    result: { appInstanceId },\r\n                    requestId: message.requestId\r\n                }, 100);\r\n                this.sendCallback({\r\n                    type: Node.EventName.INSTALL,\r\n                    data: { appInstanceId }\r\n                }, 5000);\r\n                break;\r\n            case Node.MethodName.GET_APP_INSTANCE_DETAILS:\r\n                this.sendCallback({\r\n                    type: Node.MethodName.GET_APP_INSTANCE_DETAILS,\r\n                    result: { appInstance: { id: message.params.appInstanceId } },\r\n                    requestId: message.requestId\r\n                }, 1);\r\n                break;\r\n            default:\r\n                console.error(\"Unhandled message in MockNodeProvider:\", message);\r\n        }\r\n    }\r\n    sendCallback(message, timeout) {\r\n        setTimeout(() => {\r\n            this.callback(message);\r\n        }, timeout);\r\n    }\r\n    async connect() {\r\n        if (this.isConnected) {\r\n            console.warn(\"NodeProvider is already connected.\");\r\n            return Promise.resolve(this);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            return setTimeout(() => {\r\n                this.isConnected = true;\r\n                return resolve(this);\r\n            }, 1000);\r\n        });\r\n    }\r\n}\r\n"}